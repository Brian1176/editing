<!doctype html>
<meta charset=utf-8>
<title>HTML Editing Commands</title>
<link rel=stylesheet href=http://www.whatwg.org/style/specification>
<style>
 pre, code, xmp { font-family:monospace, sans-serif; }
 h2 code, h3 code, h4 code,
 h2 :link, h3 :link, h4 :link,
 h2 :visited, h3 :visited, h4 :visited
 { font:inherit; color:inherit; font-style:italic; }
 @media print {
   :not([data-anolis-spec]) > [data-anolis-spec]::after {
     content: "[" attr(data-anolis-spec) "]";
     font-size: 0.6em;
     vertical-align: super;
     text-transform: uppercase;
   }
 }
 xmp {
   font-size: inherit;
   font-variant: normal;
   margin-left: 2em;
   white-space: pre-wrap;
 }
 div.note > p:first-child::before { content: 'Note: '; }
</style>
<body class=draft>
<div class=head id=head>
<h1>HTML Editing Commands</h1>
<h2 class="no-num no-toc">Work in Progress &mdash; Last Update [DATE: 01 Jan 1901]</h2>
<dl>
 <dt>Editor
 <dd>Aryeh Gregor &lt;ayg+spec@aryeh.name>

 <dt>Version history
 <dd><a href=http://aryeh.name/gitweb.cgi?p=editcommands>http://aryeh.name/gitweb.cgi?p=editcommands</a>
</dl>
</div>


<h2 class=no-num>Status of this Document</h2>
<p>This document is an early draft of a specification for HTML editing APIs,
defining <code>execCommand()</code> and related functions.  It will eventually
be merged into the main <a href=http://www.whatwg.org/html>HTML</a>
specification, replacing the <a
href=http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#editing-apis>Editing
APIs</a> section.  Although this spec is still very incomplete and will likely
be changed heavily before it's finished, feedback to <a
href=http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org>the WHATWG list</a>
is encouraged, particularly from implementers.


<h2 class=no-num>Table of contents</h2>
<!--toc-->


<h2>Introduction</h2>
<p>This specification defines commands to edit HTML documents programmatically.
The APIs specified here were originally introduced in Microsoft's Internet
Explorer, but have subsequently been copied by other browsers in a haphazard
and imprecise fashion.  Although the behavior specified here does not exactly
match any browser at the time of writing, it can serve as a target to converge
to in the future.

<p>Where the reasoning behind the specification is of interest, such as when
major preexisting rendering engines are known not to match it, the reasoning is
included in HTML comments so as not to distract the reader.


<h2>Issues</h2>

<ul>
  <li>Need to make CSS terminology more precise, about setting/unsetting CSS
  properties.  The intent is to modify the style attribute, CSSOM-style.
  Likewise, CSS value comparisons need to be done after serializing both
  values, so "bold" == "700" and "red" == "#f00" and so on.

  <li>Also not sure about computed style.  There are differences between
  "computed" and "used" and things like that, what do we actually want here?

  <li>The wording I use for DOM stuff is a bit of a mess, often either
  imprecise or unreasonably verbose.  I'm not quite sure how to fix it.

  <li>I haven't put any thought yet into collapsed ranges or selections.
  Currently my algorithms mostly do nothing if the selection is collapsed,
  which is of course wrong.  E.g., bold with collapsed selection should put
  &lt;b>&lt;/b> at the cursor, generally.

  <li>I also don't pay attention to what happens to the selection when you
  mutate the DOM.  This is essential.

  <li>JavaScript can modify the DOM synchronously in some cases, such as DOM
  mutation events and onunload when moving around iframes and objects.  This
  has to be dealt with somehow.  (Pointed out by Ryosuke Niwa of WebKit: <a
  href=http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2011-March/030730.html>1</a>
  <a href=http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2011-March/030751.html>2</a>)

  <li>I'm sloppy about handling things like nodes that don't descend from a
  Document, comments that are children of a Document, that sort of thing.  Not
  essential for prototyping, but needs to be cleaned up eventually.

  <li>I don't pay attention to whether designMode/contenteditable is actually
  set.  I should be doing things like not doing anything if the selection isn't
  editable, making sure not to break out of contenteditable regions, etc.
</ul>


<h2>Definitions</h2>

<p>A [[node]] is an <dfn>HTML element</dfn> if it is an [[element]] whose
[[namespace]] is the [[htmlnamespace]].  An <code
data-anolis-spec=domcore>Attr</code> is an <dfn>HTML attribute</dfn> if its
<span data-anolis-spec=domcore title=concept-attr-namespace>namespace</span> is
the [[htmlnamespace]].

<p>The <dfn>beginning element</dfn> of a [[range]] is returned by the following
algorithm:

<ol>
  <li>If the [[rangestart]] [[bpnode]] of the [[range]] is a [[text]],
  [[comment]], or [[processinginstruction]] node, and the [[rangestart]]
  [[bpoffset]] of the [[range]] is not equal to the [[nodelength]] of its
  [[rangestart]] [[bpnode]], let <var>first node</var> be the [[range]]'s
  [[rangestart]] [[bpnode]].

  <li>Otherwise, let <var>first node</var> be the first [[node]] in
  [[treeorder]] that is [[contained]] in the [[range]], if there is any.

  <li>If <var>first node</var> is defined and is an [[element]], return
  <var>first node</var>.

  <li>Otherwise, if <var>first node</var> is defined and its [[parent]] is an
  [[element]], return <var>first node</var>'s [[parent]].

  <li>Return null.
</ol>

<p>The <dfn>active range</dfn> of a [[document]] is the value returned by the
following algorithm:

<ol>
  <li>Let <var>selection</var> be the result of calling [[getselection]] on
  the [[document]].

  <li>If there are no [[range]]s associated with <var>selection</var>,
  return null.

  <li>Let <var>start</var> be the [[boundarypoint]] with the earliest
  [[bpposition]] among all of <var>selection</var>'s [[range]]s'
  [[rangestarts]].

  <li>Return the last [[range]] in <var>selection</var> whose [[rangestart]]
  is <var>start</var>.
  <!-- This is what Firefox seems to do, no reason to change it . . . -->

  <p class=note>In user agents that support only one [[range]] per
  [[selection]], the active range is simply the only one in the selection.
</ol>

<p>Given a CSS property name <var>property name</var>, an (optional) value
<var>property value</var> for that property, and a possibly empty list of
strings <var>tag list</var>, a [[node]] is a <dfn>potentially relevant styling
element</dfn> if it is an <span>HTML element</span> and one of the following
holds:

<ul>
  <li>Its [[localname]] is in <var>tag list</var> and it has no attributes.

  <li>Its [[localname]] is in <var>tag list</var> or is "span" or is "font",
  and it has exactly one attribute, and that attribute is an <span>HTML
  attribute</span> with [[attrlocalname]] "style", and that attribute sets
  exactly one CSS property, and that property is <var>property name</var>, and
  either <var>property value</var> is undefined or the value the attribute sets
  the property to is <var>property value</var>.

  <li>Its [[localname]] is "font", and it has exactly one attribute, and that
  attribute is a <code data-anolis-spec=html title=dom-font-color>color</code>
  attribute, and either <var>property value</var> is undefined or the effect of
  the attribute is to hint that the CSS color attribute be set to <var>property
  value</var>, and <var>property name</var> is "color".

  <li>Its [[localname]] is "font", and it has exactly one attribute, and that
  attribute is a <code data-anolis-spec=html title=dom-font-face>face</code>
  attribute, and either <var>property value</var> is undefined or the effect of
  the attribute is to hint that the CSS font-family attribute be set to
  <var>property value</var>, and <var>property name</var> is "font-family".

  <li>Its [[localname]] is "font", and it has exactly one attribute, and that
  attribute is a <code data-anolis-spec=html title=dom-font-size>size</code>
  attribute, and either <var>property value</var> is undefined or the effect of
  the attribute is to hint that the CSS font-size attribute be set to
  <var>property value</var>, and <var>property name</var> is "font-size".

  <!-- Should we bother handling <font color=red style=color:red>?  Let's not.
  -->
</ul>

<p>A [[node]] is a <dfn>relevant styling element</dfn> if it is a
<span>potentially relevant styling element</span>, and its CSS property
<var>property name</var> computes to <var>property value</var> (which cannot be
undefined).

<div class=note>
<p>If <var>property name</var> is "font-weight", <var>property value</var> is
"bold", and <var>tag list</var> contains "b", an example of a <span>potentially
relevant styling element</span> that is not actually <span title="relevant
styling element">relevant</span> is

<xmp><p style="font-weight: 100"><b>Foo</b></p></xmp>

<p>Since <code data-anolis-spec=html title="the b element">b</code>'s default
font-weight is "bolder", the computed font-weight will most likely end up being
"normal" or lighter.
</div>

<p>A <dfn>phrasing element</dfn> is either an <span>HTML element</span> that is
categorized as [[phrasingcontent]], or a <span data-anolis-spec=html
title="non-conforming element">non-conforming</span> <span>HTML element</span>
(which thus has no categories), or an [[element]] that is not an <span>HTML
element</span>.

<p class=XXX>We should allow unrecognized HTML elements too.

<p>The <dfn>specified style</dfn> of an [[element]] for a given <var>property
name</var> is returned by the following algorithm, which will return either a
CSS value or null:

<ol>
  <li>If the [[element]] has a <code data-anolis-spec=html
  title="the style attribute">style</code> attribute set, and that attribute has
  the effect of setting <var>property name</var>, return the value that it sets
  <var>property name</var> to.

  <li>If the [[element]] is a <code data-anolis-spec=html>font</code> element
  that has an attribute whose effect is to create a [[presentationalhint]] for
  <var>property name</var>, return the value that the hint sets <var>property
  name</var> to.

  <li>If the [[element]] is in the following list, and <var>property name</var>
  is equal to the CSS property name listed for it, return the string listed for
  it.

  <p class=XXX>Add any other elements that can be output by the style/unstyle
  algorithms, or existing browser implementations of execCommand().

  <dl class=switch>
    <dt><code data-anolis-spec=html title="the b element">b</code>
    <dt><code data-anolis-spec=html title="the strong element">strong</code>
    <dd>font-weight: "bold"

    <dt><code data-anolis-spec=html title="the i element">i</code>
    <dt><code data-anolis-spec=html title="the em element">em</code>
    <dd>font-style: "italic"

    <dt><code data-anolis-spec=html title="the u element">u</code>
    <dd>text-decoration: "underline"
  </dl>

  <li>Return null.
</ol>

<p>When the user agent is instructed to run a particular method, it must follow
the steps defined for that method in the appropriate specification, not act as
though the method had actually been called from JavaScript.  In particular,
if the author has overridden the method with a custom method, the standard
method must be run rather than the custom one.

<p>When a list or set of [[node]]s is assigned to a variable without specifying
the order, they must be initially in [[treeorder]], if they share a root.
(If they don't share a root, the order will be specified.)  When the user agent
is instructed to run particular steps for each member of a list, it must do so
sequentially in the list's order.


<h2>Decomposing a Range into Nodes</h2>
<p>When a user agent is to <dfn>decompose a [[range]]</dfn> <var>range</var>,
it must run the following steps.

<ol>
  <li>If <var>range</var>'s [[rangestart]] and [[rangeend]] are the same,
  return an empty list.

  <li>Let <var>start node</var>, <var>start offset</var>, <var>end node</var>,
  and <var>end offset</var> be <var>range</var>'s [[rangestart]] and
  [[rangeend]] [[bpnodes]] and [[bpoffsets]], respectively.

  <li>If <var>start node</var> is a [[text]] node and is the same as <var>end
  node</var>, and <var>start offset</var> is neither 0 nor the [[nodelength]]
  of <var>start node</var>:
  
  <ol>
    <li>Set <var>start node</var> to the result of running <code
    data-anolis-spec=domcore title=dom-Text-splitText>splitText(<var>start
    offset</var>)</code> on <var>start node</var>.

    <li>Set <var>end node</var> to <var>start node</var>.

    <li>Set <var>end offset</var> to <var>end offset</var> &minus; <var>start
    offset</var>.

    <li>Set <var>start offset</var> to 0.
  </ol>

  <li>Otherwise, if <var>start node</var> is a [[text]] node and <var>start
  offset</var> is neither 0 nor the [[nodelength]] of <var>start node</var>:

  <ol>
    <li>Set <var>start node</var> to the result of running <code
    data-anolis-spec=domcore title=dom-Text-splitText>splitText(<var>start
    offset</var>)</code> on <var>start node</var>.

    <li>Set <var>start offset</var> to 0.
  </ol>

  <li>If <var>end node</var> is a [[text]] node and <var>end offset</var> is
  neither 0 nor the [[nodelength]] of <var>end node</var>, run <code
  data-anolis-spec=domcore title=dom-Text-splitText>splitText(<var>end
  offset</var>)</code> on <var>end node</var>.

  <!-- The next two steps ensure that our fragmented text nodes are contained
  in the range. -->
  <li>If <var>start node</var> is a [[text]] node and <var>start offset</var>
  is 0, set <var>start offset</var> to the [[index]] of <var>start node</var>,
  then set <var>start node</var> to its [[parent]].

  <li>If <var>end node</var> is a [[text]] node and <var>end offset</var> is
  its [[nodelength]], set <var>end offset</var> to one plus the [[index]] of
  <var>end node</var>, then set <var>end node</var> to its parent.

  <li>Set <var>range</var>'s [[rangestart]] to (<var>start node</var>,
  <var>start offset</var>) and its [[rangeend]] to (<var>end node</var>,
  <var>end offset</var>).

  <li>Return a list consisting of every [[node]] [[contained]] in
  <var>range</var> in [[treeorder]], omitting any whose [[parent]] is also
  [[contained]] in <var>range</var>.
</ol>


<h2>Clearing an element's styles</h2>
<p>When a user agent is to <dfn>clear styles</dfn> on an element, it must run
the following steps:

<div class=note>
<p>Clearing styles (<span title="recursively clear styles">recursively</span>
or not) can remove it from its parent and put other nodes in its place.  When
implementations do something like clear style on all children of an element,
they should take care not to assume that the set of children won't change as
they're unstyled.  If the element is removed, the algorithm will return the
list of nodes inserted in its place.

<p>Clearing styles only removes inline styles from the element.  It doesn't
ensure that the element isn't inheriting styles from an ancestor (or a style
rule).  For that, one must <span>unstyle a node</span>.
</div>

<ol>
  <li>Let <var>element</var> be the [[element]] to be unstyled.

  <li>Let <var>property name</var> and <var>tag list</var> be as
  in the invoking algorithm.

  <li>If <var>element</var> is a <span>potentially relevant styling
  element</span>:

  <ol>
    <li>Let <var>children</var> be an empty list of [[node]]s.

    <li>While <var>element</var> has children:

    <ol>
      <li>Let <var>child</var> be the first child of <var>element</var>.

      <li>Append <var>child</var> to <var>children</var>.

      <li>Insert <var>child</var> as the previous sibling of
      <var>element</var>.
    </ol>

    <li>Remove <var>element</var>.

    <li>Return <var>children</var>.
  </ol>

  <li>Unset the CSS property <var>property name</var> of <var>element</var>.

  <li>If <var>element</var> is a <code data-anolis-spec=html>font</code>
  element:

  <ol>
    <li>If <var>property name</var> is "color", unset <var>element</var>'s
    <code data-anolis-spec=html title=dom-font-color>color</code> attribute, if
    set.

    <li>If <var>property name</var> is "font-family", unset
    <var>element</var>'s <code data-anolis-spec=html
    title=dom-font-face>face</code> attribute, if set.

    <li>If <var>property name</var> is "font-size", unset <var>element</var>'s
    <code data-anolis-spec=html title=dom-font-size>size</code> attribute, if
    set.
  </ol>

  <li>If <var>element</var> is not an <span>HTML element</span> or its
  [[localname]] is not in <var>tag list</var>, return the empty list.
  <!-- If we get past this step, we're something like <b class=foo> where we
  want to keep the extra attributes, so we stick them on a span. -->

  <li>Let <var>new element</var> be a new <span>HTML element</span> with
  [[localname]] "span", with the same attributes and [[ownerdocument]] as
  <var>element</var>.

  <li>Append <var>new element</var> to <var>element</var>'s
  parent as the previous sibling of <var>element</var>.

  <li>While <var>element</var> has children, append its first child
  as the last child of <var>new element</var>.

  <li>Remove <var>element</var>.

  <li>Return the one-[[node]] list consisting of <var>new element</var>.
</ol>


<h2>Recursively clearing an element's styles</h2>
<p>When a user agent is to <dfn>recursively clear styles</dfn> on an element,
it must run the following steps:

<ol>
  <li>Let <var>element</var> be the [[element]] to be unstyled.

  <li>Let <var>property name</var> and <var>tag list</var> be as
  in the invoking algorithm.

  <li>Let <var>element children</var> be the [[element]] children of
  <var>element</var>.

  <li><span>Recursively clear styles</span> on each [[element]] in <var>element
  children</var>.

  <li><span>Clear styles</span> on <var>element</var>, and return the resulting
  list.
</ol>


<h2>Styling a Node</h2>
<p>When a user agent is to <dfn>style a [[node]]</dfn> <var>node</var>, it must
run the following steps.  There are three inputs: a CSS property name
<var>property name</var>, a new value <var>property value</var>, and a possibly
empty list of strings <var>tag list</var>.

<p class=note>This algorithm applies the given style to the node itself, but
doesn't interfere with conflicting styles on its descendants.  <span
title="recursively style a node">Recursive styling</span> removes conflicting
styles from descendants first.

<ol>
  <li>If <var>node</var>'s [[parent]] is null, or if <var>node</var> is not an
  [[element]], [[text]], [[comment]], or [[processinginstruction]] node, abort
  this algorithm. <!-- XXX: What to do here? -->

  <li>If <var>node</var> is an [[element]]:

  <ol>
    <li><span>Clear styles</span> on <var>node</var>, and let <var>new
    nodes</var> be the result.

    <li>For each <var>new node</var> in <var>new nodes</var>, <span
    title="style a node">style <var>new node</var></span>, with the same inputs
    as this invocation of the algorithm.

    <li>If <var>node</var>'s [[parent]] is null, abort this algorithm.
  </ol>

  <li>If <var>node</var> is an [[element]] but not a <span>phrasing
  element</span>:

  <ol>
    <li>Let <var>children</var> be all [[children]] of <var>node</var>,
    omitting any that are [[element]]s whose <span>specified style</span> for
    <var>property name</var> is neither null nor equal to <var>property
    value</var>.

    <li><span title="style a node">Style</span> each [[node]] in
    <var>children</var>.

    <li>Abort this algorithm.
  </ol>

  <li>If <var>node</var>'s [[previoussibling]] is a <span>relevant styling
  element</span>, append <var>node</var> as the last [[child]] of its
  [[previoussibling]] and abort this algorithm.

  <li>If <var>node</var>'s [[nextsibling]] is a <span>relevant styling
  element</span>, insert <var>node</var> as the first [[child]] of its
  [[nextsibling]] and abort this algorithm.

  <li>If <var>node</var> is a [[comment]] or [[processinginstruction]], abort
  this algorithm.  <!-- There's no point in making a new element in this case.
  -->

  <li>If <var>node</var> is an [[element]] and the computed style of
  <var>property name</var> for it is <var>property value</var>, abort this
  algorithm.

  <li>If <var>node</var> is a [[text]] node and the computed style of
  <var>property name</var> for its [[parent]] is <var>property value</var>,
  abort this algorithm.

  <li>Let <var>tag</var> be the first string in <var>tag list</var>, if that is
  not empty, or "span" if it is empty.

  <li>Let <var>new parent</var> be the result of calling <code
  data-anolis-spec=domcore
  title=dom-Document-createElement>createElement(<var>tag</var>)</code> on the
  [[ownerdocument]] of <var>node</var>.

  <li>Insert <var>new parent</var> in <var>node</var>'s [[parent]] before
  <var>node</var>.

  <li>If the computed value of <var>property name</var> for <var>new
  parent</var> is not <var>property value</var>, set the CSS property
  <var>property name</var> of <var>new parent</var> to <var>property
  value</var>.

  <li>Append <var>node</var> to <var>new parent</var> as its last [[child]].
</ol>


<h2>Recursively styling a Node</h2>
<p>When a user agent is to <dfn>recursively style a [[node]]</dfn>
<var>node</var>, it must run the following steps.  There are three inputs: a
CSS property name <var>property name</var>, a new value <var>property
value</var>, and a possibly empty list of strings <var>tag list</var>.

<ol>
  <li>If <var>node</var>'s [[parent]] is null, or if <var>node</var> is not an
  [[element]], [[text]], [[comment]], or [[processinginstruction]] node, abort
  this algorithm. <!-- XXX: What to do here? -->

  <li>If <var>node</var> is an [[element]]:

  <ol>
    <li><span>Recursively clear styles</span> on <var>node</var>, and let
    <var>new nodes</var> be the result.

    <li>For each <var>new node</var> in <var>new nodes</var>, <span
    title="recursively style a node">recursively style <var>new
    node</var></span>, with the same inputs as this invocation of the
    algorithm.

    <li>If <var>node</var>'s [[parent]] is null, abort this algorithm.
  </ol>

  <li><span title="style a node">Style</span> <var>node</var>.
</ol>


<h2>Styling a Range</h2>
<p>When a user agent is to <dfn>style a [[range]]</dfn>, it must <span
title="decompose a range">decompose</span> the [[range]], then <span
title="recursively style a node">recursively style</span> each [[node]] in the
returned list.


<h2>Unstyling a Node</h2>
<p>When a user agent is to <dfn>unstyle a [[node]]</dfn> <var>node</var>, it
must run the following steps.  There are three inputs: a CSS property name
<var>property name</var>, a new value <var>new value</var>, and a possibly
empty list of strings <var>tag list</var>.

<ol>
  <li>If <var>node</var>'s [[parent]] is null, or if <var>node</var> is not an
  [[element]] or [[text]] node, abort this algorithm. <!-- XXX: What to do
  here?  We want to ignore comments and PIs, but we might want to support
  detached elements, documents, document fragments, . . . -->

  <li>If <var>node</var> is an [[element]]:

  <ol>
    <li><span>Recursively clear styles</span> on <var>node</var>, and let
    <var>new nodes</var> be the result.

    <li>For each <var>new node</var> in <var>new nodes</var>, <span
    title="unstyle a node">unstyle <var>new node</var></span>, with the same
    inputs as this invocation of the algorithm.

    <li>If <var>node</var>'s [[parent]] is null, abort this algorithm.
  </ol>

  <li>If <var>node</var> is an [[element]], let <var>current value</var> equal
  the computed value of <var>property name</var> on <var>node</var>.
  Otherwise, let <var>current value</var> equal the computed value of
  <var>property name</var> on <var>node</var>'s [[parent]].

  <li>If <var>current value</var> equals <var>new value</var>, abort this
  algorithm.

  <li>Let <var>ancestor list</var> be a list of [[node]]s, initially empty.

  <li>Let <var>current ancestor</var> equal <var>node</var>.

  <li>While <var>current ancestor</var>'s [[parent]] is an [[element]], set
  <var>current ancestor</var> to its [[parent]], then append it to
  <var>ancestor list</var>.
  
  <li>While <var>ancestor list</var> is not empty, and the last member of
  <var>ancestor list</var> has <span>specified style</span> for <var>property
  name</var> equal to <var>new value</var> or null, remove the last member from
  <var>ancestor list</var>.

  <li>While <var>ancestor list</var> is not empty:

  <ol>
    <li>Let <var>current ancestor</var> be the last member of <var>ancestor
    list</var>.

    <li>Remove the last member from <var>ancestor list</var>.

    <li>Let <var>propagated value</var> be the <span>specified style</span> of
    <var>current ancestor</var> for <var>property name</var>.

    <li>If <var>propagated value</var> is null, continue this loop from the
    beginning.

    <li>Let <var>children</var> be the [[children]] of <var>current
    ancestor</var>.

    <li><span>Clear styles</span> on <var>current ancestor</var>.

    <li>For every <var>child</var> in <var>children</var>:

    <ol>
      <li>If <var>child</var> is <var>node</var>, continue with the next
      <var>child</var>.

      <li>If <var>child</var> is an [[element]] whose <span>specified
      style</span> for <var>property name</var> is neither null nor equal to
      <var>propagated value</var>, continue with the next <var>child</var>.

      <li>If <var>child</var> is the last member of <var>ancestor list</var>,
      set <var>child</var>'s CSS property <var>property name</var> to
      <var>propagated value</var> and continue with the next <var>child</var>.

      <p class=note>This style will be removed on the next loop iteration and
      distributed to its children.

      <li><span title="style a node">Style</span> <var>child</var>, with
      <var>property name</var> and <var>tag list</var> as in this algorithm,
      and <var>property value</var> equal to <var>propagated value</var>.
    </ol>
  </ol>

  <!-- We might have a rule inherited from someplace where we can't remove it,
  or maybe even a rule in a stylesheet (although that case is pathological and
  we generally ignore it) -->
  <li>If <var>node</var> is an [[element]] and <var>property name</var> does
  not compute to <var>new value</var> on it, set <var>property name</var> to
  <var>new value</var> on it.

  <li>If <var>node</var> is a [[text]] node and <var>property name</var> does
  not compute to <var>new value</var> on its [[parent]]:

  <ol>
    <li>Let <var>new parent</var> be the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("span")</code> on the
    [[ownerdocument]] of <var>node</var>.

    <li>Set <var>property name</var> to <var>new value</var> on <var>new
    parent</var>.

    <li>Insert <var>new parent</var> into <var>node</var>'s [[parent]] before
    <var>node</var>.

    <li>Append <var>node</var> as the last [[child]] of <var>new parent</var>.
  </ol>
</ol>


<h2>Unstyling a Range</h2>
<p>When a user agent is to <dfn>unstyle a [[range]]</dfn> <var>range</var>, it
must <span title="decompose a range">decompose</span> the [[range]], then <span
title="unstyle a node">unstyle</span> each [[node]] in the returned list.


<h2>Commands</h2>
<p>The <dfn title=execCommand()><code>execCommand(<var>commandId</var>,
<var>showUI</var>, <var>value</var>)</code></dfn> method on the
<code data-anolis-spec=html>HTMLDocument</code> interface allows scripts to
perform actions on the current selection or at the current caret position.
Generally, these commands would be used to implement editor UI, for example
having a "delete" button on a toolbar.

<p>There are three variants to this method, with one, two, and three arguments
respectively. The <var>showUI</var> and <var>value</var>
parameters, even if specified, are ignored except where otherwise stated.

<p>When <code>execCommand()</code> is invoked, the user agent must take the
action from the list below given by <var>commandId</var> on the
[[contextobject]]'s <span>active range</span>.  If no action is given or if
there is no <span>active range</span>, do nothing.

<p>The <dfn
title=queryCommandState()><code>queryCommandState(<var>commandId</var>)</code></dfn>
method on the <code data-anolis-spec=html>HTMLDocument</code> interface must
return the state of <var>commandId</var> on the [[contextobject]]'s
<span>active range</span>, as given by the list below.  If there is no
<span>active range</span>, or if <var>commandId</var> is not on the list,
return false.
<!-- Gecko throws an exception if there are no ranges in the selection, but
other engines seem to just return false, which seems like nicer behavior
anyway.

Requesting the state of an unknown command throws an exception in IE 9 RC
and Firefox 4b11, and returns boolean false in Chrome 10 and Opera 11. -->

<p>The <dfn
title=queryCommandValue()><code>queryCommandValue(<var>commandId</var>)</code></dfn>
method on the <code data-anolis-spec=html>HTMLDocument</code> interface must
return the value of <var>commandId</var> on the [[contextobject]]'s
<span>active range</span>, as given by the list below.  If there is no
<span>active range</span>, or if <var>commandId</var> is not on the list,
return the empty string.
<!-- Requesting the value of an unknown command throws an exception in
IE 9 RC and in Firefox 4b11.  It returns boolean false in Chrome 10, and the
empty string in Opera 11. -->

<p class=XXX>Querying the value or state of an unrecognized command throws an
exception in IE and Firefox.  Need to consider changing to that behavior.

<p>The possible values for <var>commandId</var>, and their corresponding
meanings, are as follows.  These values must be compared to the argument in an
<span data-anolis-spec=domcore>ASCII case-insensitive</span> manner.

<dl>
<dt><code title><dfn title=command-backColor>backColor</dfn></code>

<dd><p><strong>Action</strong>: If <var>value</var> is not a valid CSS color,
the user agent must do nothing and abort these steps.  Otherwise, it must <span
title="style a range">style the [[range]]</span> with <var>property name</var>
equal to "background-color", <var>property value</var> equal to
<var>value</var>, and <var>tag list</var> equal to the empty list.
<!-- Firefox documentation says it normally sets the background color of the
document, but I can't get it to work at all in brief testing in 4b11.  (It says
it behaves differently in styleWithCss mode.)  Opera 11 appears to set the
background color of the nearest block container of the cursor, or something.
IE 9 RC and Chrome 10 behave as I'd expect, namely, they set the background of
the selection, just like all the other styling features.  I go with IE/WebKit.

Invalid colors are probably the same craziness as with foreColor.

Chrome 10 dev actually sets background, not background-color, so it resets all
the other background stuff.  I go with IE 9 RC and Opera 11, which only set
background-color. -->

<p class=XXX>Firefox and Opera use backColor to set the background color of the
whole document.  The hiliteColor command can then be used to set the background
of the selection (supported in all my test browsers except IE).  This
terminology is inconsistent with foreColor, but the model I've specced leaves
no way to change the document's overall background color.  I'm not sure how
important this is, but maybe I should switch, since hiliteColor is more
interoperably implemented than backColor.

<dd><p><strong>State</strong>: Always false.

<dd><p><strong>Value</strong>: The value is given by the following algorithm:

<ol>
  <li>Let <var>element</var> be the <span>beginning element</span> of the
  [[range]].

  <li>While the computed style of "background-color" on <var>element</var>
  is any fully transparent value, set <var>element</var> to its parent.

  <p class=XXX>It's intended that for these purposes, the root element will
  have a white background.  Should that be specified somewhere?  I don't think
  all UAs actually do it.

  <li>Return the computed style of "background-color" for
  <var>element</var>.
</ol>
<!-- Chrome 10 returns rgba(0, 0, 0, 0) if there's no background defined
anywhere.  Opera 11 returns rgb(255, 255, 255) as I'd like.  Firefox 4b11 just
throws an exception for some reason.  IE 9 RC seems to return the number 0
across the board, as with foreColor. -->


<dt><code title><dfn title=command-bold>bold</dfn></code>

<dd><p><strong>Action</strong>: If the state of the [[range]] for this command
is false, the user agent must <span title="style a range">style the
[[range]]</span> with <var>property name</var> "font-weight", <var>property
value</var> "bold", and <var>tag list</var> ["b", "strong"].  Otherwise, it
must <span title="unstyle a range">unstyle it</span> with <var>property
name</var> "font-weight", <var>property value</var> "normal", and <var>tag
list</var> ["b", "strong"].

<dd><p><strong>State</strong>: True if the <span>beginning element</span> of the
[[range]] has font-weight with computed value less than 700, otherwise false.

<dd><p><strong>Value</strong>: Always the empty string.
<!-- We have lots of options here (and presumably for all the others where
value is meaningless).  IE 9 RC returns the boolean false, Firefox 4b11 and
Opera 11 both return the empty string, Chrome 10 returns the string "false".
The HTML5 spec as of February 2011 mandates WebKit's behavior.  It makes sense
to always return a string, a majority of string-returners return the empty
string, and three out of the four return something that evaluates to false as a
boolean, so I'll go with Firefox and Opera. -->


<dt><code title><dfn title=command-createlink>createLink</dfn></code>

<dd><p><strong>Action</strong>: The user agent must run the following steps:

<ol>
  <li>If <var>value</var> is the empty string, abort these steps and do
  nothing.
  <!-- This matches Firefox 4b11 and Chrome 11 dev.  IE 9 RC and Opera 11 both
  treat the request literally.  Gecko and WebKit probably have it right here:
  users who enter no URL are very unlikely to want to link to a relative URL
  resolving to the current document.  If they really want to, they can always
  specify "#" for the value, or the author can rewrite it, so it's not like
  this makes the API less useful. -->

  <li>Let <var>node list</var> be the result of <span title="decompose a
  range">decomposing</span> the [[range]].

  <li>For each <var>node</var> in <var>node list</var>, in order:

  <ol>
    <li>Let <var>text nodes</var> be a list of all [[text]] node
    [[descendants]] of <var>node</var>, or <var>node</var> itself if it's a
    [[text]] node.

    <li>For each <var>text node</var> in <var>text nodes</var>, in
    [[treeorder]]:

    <ol>
      <li>Let <var>ancestor link</var> be the parent of <var>text
      node</var>.

      <li>While <var>ancestor link</var> is not an <span>HTML
      element</span>, or its [[localname]] is not "a", or it has no <span>HTML
      attribute</span> with [[attrlocalname]] "href":

      <ol>
        <li>If the parent of <var>ancestor link</var> is not an [[element]],
        set <var>ancestor link</var> to null and break from this loop.

        <li>Otherwise, set <var>ancestor link</var> to its parent.
      </ol>

      <li>If <var>ancestor link</var> is not null, set its "href" attribute
      to <var>value</var> and continue with the next <var>text node</var>.
      <!-- There are three approaches here.  For instance, if you ask browsers
      to create a link to "http://example.org" on the "b" here:

        <a href=http://example.com><b>Abc</b></a>

      Chrome 10 dev produces:

        <b><a href=http://example.com>A</a><a href=http://example.org>b</a>
        <a href=http://example.com>c</a></b>

      Firefox 4b11 produces (roughly):

        <a href=http://example.com><b>A<a href=http://example.org>b</a>c</b></a>

      IE 9 RC and Opera 11 produce simply:

        <a href=http://example.org><b>Abc</b></a>

      The last behavior produces valid markup (unlike Gecko), is simple (unlike
      WebKit), and probably best matches user expectations.  If you happen to
      miss out a character when selecting the link you want to change, do you
      really intend to only change the link of part of it? -->

      <li>Let <var>new parent</var> be the result of calling <code
      data-anolis-spec=domcore
      title=dom-Document-createElement>createElement("a")</code> on the
      [[ownerdocument]] of <var>text node</var>.

      <li>Call <code data-anolis-spec=domcore
      title=dom-Element-setAttribute>setAttribute("href",
      <var>value</var>)</code> on <var>new parent</var>.

      <li>Insert <var>new parent</var> into <var>text node</var>'s parent as
      the previous sibling of <var>text node</var>.

      <li>Append <var>text node</var> to <var>new parent</var> as its last
      child.
    </ol>
  </ol>
</ol>

<dd><p><strong>State</strong>: Always false.

<dd><p><strong>Value</strong>: Always the empty string.
<!-- I'd have expected the value to be the URL, but guess not. -->


<dt><code title><dfn title=command-fontname>fontName</dfn></code>

<dd><p><strong>Action</strong>: The user agent must <span title="style a
range">style the [[range]]</span> with <var>property name</var> equal to
"font-family", <var>property value</var> equal to <var>value</var>, and
<var>tag list</var> equal to the empty list.
<!-- UAs differ a bit in the details here:

IE 9 RC: Empty string sets <font face="">
Firefox 4b11: Empty string does nothing
Chrome 11 dev: Empty string does nothing, '"monospace"' same as 'monospace'
  (i.e., cannot escape font-family keywords because quotes are stripped,
  clearly wrong)
Opera 11: Empty string sets <font face="">

Setting an empty font-family has the effect of inheriting the font from the
parent (although I don't see where the February 24, 2011 CSS 3 Fonts draft says
that).  Thus it makes sense that if we special-case this, it should be to unset
the font somehow.

Special-casing the empty string to do nothing doesn't make sense to me.  With
createLink we'd expect the user to enter the URL themselves, so it makes sense
to special-case clicking OK without entering anything.  But here it's very
likely that the font list will be fixed by the author (how many users will
understand CSS font-family syntax?), so I don't think such usability concerns
apply. -->

<dd><p><strong>State</strong>: Always false.

<dd><p><strong>Value</strong>: The computed value of the CSS property
"font-family" for the <span>beginning element</span> of the [[range]].
<!-- Complicated.

IE 9 RC: Always the empty string.  Not very useful.
Firefox 4b11: Confusing.  Sometimes it returns generic family names, like
  "sans-serif".  Sometimes it gives specific font names, like "tt" when the
  font is specified as "monospace".  Sometimes it gives the literal font-family
  string.  Not sure what it's doing here.
Chrome 11 dev: Gives the literal value of font-family, except if it's inherited
  from default values (no explicit style declarations anywhere), when it seems
  to return the exact font name.
Opera 11: Returns the literal value of font-family, except if it's inherited
  from default values, when it returns the empty string.

I'm just going to punt on this and say it should be the computed value of
font-family.  I'll leave CSSOM to decide what that means if there are no
applicable style rules. -->


<dt><code title><dfn title=command-forecolor>foreColor</dfn></code>

<dd><p><strong>Action</strong>: If <var>value</var> is not a valid CSS color,
the user agent must do nothing and abort these steps.
<!-- Browsers are all over the place here.  IE 9 RC seems to treat unrecognized
colors as black, but everyone else ignores them.  There are also special rules
for certain things that aren't valid CSS colors, in some browsers, like:

IE 9 RC: "ffe" -> "#ffe", "123" -> "#123"
Firefox 4b11: "ffe" -> no style, "123" -> no style
Chrome 10 dev: "ffe" -> "#FFFFEE", "123" -> "#000123"
Opera 11: "ffe" -> "#0f0f0e", "123" -> "#010203"

Firefox seems to stick to just CSS colors, so with any luck that works.
"limegreen" works as expected in all browsers.  rgb(255, 255, 255) does too,
except in Opera, which tries to parse it in some crazy way and winds up with
"#00b025".  rgba() colors don't work as uniformly, but I don't see any reason
to prohibit them.  Best to just match CSS. -->
Otherwise, it must <span title="style a range">style the [[range]]</span> with
<var>property name</var> equal to "color", <var>property value</var> equal to
<var>value</var>, and <var>tag list</var> equal to the empty list.

<dd><p><strong>State</strong>: Always false.
<!-- This matches IE 9 RC and Chrome 10.  Opera 11 seems to return true if
there's some color style applied, false otherwise, which seems fairly useless;
authors want to use value here, not state.  Firefox 4b11 throws an exception,
which is an interesting approach, but I'll go with IE/WebKit, which makes at
least as much sense. -->

<dd><p><strong>Value</strong>: The computed value of the CSS property "color"
for the <span>beginning element</span> of the [[range]].
<!-- IE 9 RC returns the number 0 always, which makes no sense at all.  This
matches the other browsers. -->


<dt><code title><dfn title=command-insertimage>insertImage</dfn></code>

<dd><p><strong>Action</strong>: The user agent must run the following steps:

<ol>
  <li>If <var>value</var> is the empty string, abort these steps and do
  nothing.
  <!-- Similar logic to createLink, except even more compelling, since an HTML
  document linking to itself as an image is just silly.  In fact, the current
  HTML spec instructs UAs to not even try displaying the image, and just fail
  immediately if the URL is empty.  Firefox 4b11 bails out on an empty string,
  but the other three browsers I tested stick in the <img> anyway. -->

  <li>Run <code data-anolis-spec=domrange
  title=dom-Range-deleteContents>deleteContents()</code> on the [[range]].

  <li>Let (<var>node</var>, <var>offset</var>) be the [[range]]'s
  [[rangestart]].

  <li>Let <var>img</var> be a new <span>HTML element</span> with
  [[localname]] "img", the same [[ownerdocument]] as <var>node</var>, and a
  single <span>HTML attribute</span> with [[attrlocalname]] "src" and with
  [[attrvalue]] <var>value</var>.
  <!-- No alt text, so it's invalid.  This matches all browsers. -->

  <li>If <var>node</var> is a [[text]] node, and <var>offset</var> is not
  equal to 0 or the [[nodelength]] of <var>node</var>, run <code
  data-anolis-spec=domcore
  title=dom-Text-splitText>splitText(<var>offset</var>)</code> on
  <var>node</var>.

  <li>If <var>node</var> is a [[text]], [[comment]], or
  [[processinginstruction]] node, run <code data-anolis-spec=domcore
  title=dom-Node-insertBefore>insertBefore(<var>img</var>,
  <var>node</var>)</code> on the parent of <var>node</var>.

  <li>Otherwise, let <var>child</var> be the <var>offset</var>th child of
  <var>node</var> (or null if there is no such child), and run <code
  data-anolis-spec=domcore
  title=dom-Node-insertBefore>insertBefore(<var>img</var>,
  <var>child</var>)</code> on <var>node</var>.
</ol>

<dd><p><strong>State</strong>:

<dd><p><strong>Value</strong>:


<dt><code title><dfn title=command-italic>italic</dfn></code>

<dd><p><strong>Action</strong>: If the of the [[range]] for this command is
false, the user agent must <span title="style a range">style the
[[range]]</span> with <var>property name</var> "font-style", <var>property
value</var> "italic", <var>tag list</var> ["i", "em"].  Otherwise, it must
<span title="unstyle a range">unstyle it</span> with <var>property name</var>
"font-style", <var>property value</var> "normal", and <var>tag list</var> ["i",
"em"].

<dd><p><strong>State</strong>: True if the <span>beginning element</span> of the
[[range]] has font-style with computed value "italic" or "oblique", otherwise
false.

<dd><p><strong>Value</strong>: Always the empty string.


<dt><code title><dfn title=command-unlink>unlink</dfn></code>

<dd><p><strong>Action</strong>: The user agent must execute the following
steps:
<!-- IE 9 RC unlinks the whole link you're pointing at.  Others just unlink
your selection, which does nothing if you have nothing selected.
Unfortunately, everyone but IE winds up doing some DOM surgery here in some
cases, creating and splitting elements in some cases. -->

<p class=XXX>This is based on what IE does.  Other browsers only unlink the
selected portion, which might be more user-friendly but involves chopping up
and reorganizing the DOM.  Revisit this later to see if it's reasonable to spec
what the other browsers do instead.

<ol>
  <li>Let <var>links</var> be a [[collection]] rooted at the [[range]]'s
  [[rangeroot]], whose filter matches only <span title="HTML element">HTML
  elements</span> with [[localname]] "a", that have an <span>HTML
  attribute</span> with [[attrlocalname]] "href".

  <li>Let <var>selected</var> be a [[collection]] rooted at the [[range]]'s
  [[rangeroot]], whose filter matches only [[node]]s that are [[contained]] in
  the [[range]] and [[text]] nodes that are [[partiallycontained]] in the
  [[range]].

  <li>For each <var>link</var> in <var>links</var>, in [[treeorder]]:

  <ol>
    <li>If <var>link</var> is not in <var>selected</var> and is not an
    [[ancestor]] of any [[node]] in <var>selected</var>, continue with the next
    <var>link</var>.

    <li>While <var>link</var> has children, insert <var>link</var>'s first
    child into its parent as <var>link</var>'s previous sibling.

    <li>Remove <var>link</var>.

    <p class=XXX>This means it disappears even if it had an id, class, etc.
    Maybe not what we want?
  </ol>
</ol>

<dd><p><strong>State</strong>: Always false.

<dd><p><strong>Value</strong>: Always the empty string.


<dt><code title><dfn title=command-underline>underline</dfn></code>

<dd class=XXX><p><strong>Action</strong>: ???  This is totally unreasonable,
because CSS text-decoration is a nightmare.  Styling is easy, unstyling is only
possible through massive hacks.

<dd class=XXX><p><strong>State</strong>: ...

<dd><p><strong>Value</strong>: Always the empty string.
</dl>


<h2 class=no-num id=references>References</h2><!--REFS-->
<p>All references are normative unless marked "Non-normative".</p>
<div id=anolis-references></div>


<h2 class=no-num>Acknowledgements</h2>
<p>Thanks to:

<ul>
  <li>Google, for funding this work
  <li>Ian Hickson, for overseeing it
  <li>Julie Parent, Ojan Vafai, Alex Russel, and Eric Seidel for their <a
  href=http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2009-December/024627.html>research</a>
  on how browsers and other rich text editors behave in many common scenarios
  <li>Ryosuke Niwa, Julie Parent, and Roland Steiner for their feedback on
  drafts of this document
</ul>

<script src=http://www.whatwg.org/specs/web-apps/current-work/dfn.js></script>
<!-- vim: set expandtab shiftwidth=2 tabstop=2: -->
