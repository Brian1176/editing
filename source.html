<!doctype html>
<meta charset=utf-8>
<title>HTML Editing Commands</title>
<link rel=stylesheet href=http://www.whatwg.org/style/specification>
<style>
 pre, code, xmp { font-family:monospace, sans-serif; }
 h2 code, h3 code, h4 code,
 h2 :link, h3 :link, h4 :link,
 h2 :visited, h3 :visited, h4 :visited
 { font:inherit; color:inherit; font-style:italic; }
 @media print {
   :not([data-anolis-spec]) > [data-anolis-spec]::after {
     content: "[" attr(data-anolis-spec) "]";
     font-size: 0.6em;
     vertical-align: super;
     text-transform: uppercase;
   }
 }
 xmp {
   font-size: inherit;
   font-variant: normal;
   margin-left: 2em;
   white-space: pre-wrap;
 }
 div.note > p:first-child::before { content: 'Note: '; }
 div + * > li { margin: 1em 0 }
</style>
<body class=draft>
<div class=head id=head>
<h1>HTML Editing Commands</h1>
<h2 class="no-num no-toc">Work in Progress &mdash; Last Update [DATE: 01 Jan 1901]</h2>
<dl>
 <dt>Editor
 <dd>Aryeh Gregor &lt;ayg+spec@aryeh.name>

 <dt>Version history
 <dd><a href=http://aryeh.name/gitweb.cgi?p=editcommands>http://aryeh.name/gitweb.cgi?p=editcommands</a>
</dl>
</div>


<h2 class=no-num>Status of this Document</h2>
<p>This document is an early draft of a specification for HTML editing APIs,
defining <code>execCommand()</code> and related functions.  It will eventually
be merged into the main <a href=http://www.whatwg.org/html>HTML</a>
specification, replacing the <a
href=http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#editing-apis>Editing
APIs</a> section.  Although this spec is still very incomplete and will likely
be changed heavily before it's finished, feedback to <a
href=http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org>the WHATWG list</a>
is encouraged, particularly from implementers and particularly from authors who
have experience using this feature.


<h2 class=no-num>Table of contents</h2>
<!--toc-->


<h2>Introduction</h2>
<p>This specification defines commands to edit HTML documents programmatically.
The APIs specified here were originally introduced in Microsoft's Internet
Explorer, but have subsequently been copied by other browsers in a haphazard
and imprecise fashion.  Although the behavior specified here does not exactly
match any browser at the time of writing, it can serve as a target to converge
to in the future.

<p>Where the reasoning behind the specification is of interest, such as when
major preexisting rendering engines are known not to match it, the reasoning is
included in HTML comments so as not to distract the reader.

<p>The principles I've used for writing this specification so far are:

<ul>
  <li>If all browsers that implement a particular feature agree on some detail
  of how it works, match them unless there's very good reason not to.  When
  it's not clear what behavior is best, try to follow the implementations with
  the most market share.  But if one browser's behavior is clearly better than
  the others', go with the better behavior.

  <li>If a command is issued to format some text in a particular way, we will
  format the text that way no matter what.  If the user clicks the "bold"
  button, they don't care that the text didn't become bold because of an
  external CSS rule or for any other reason, they only care that it didn't
  work.  The only exception (beyond where it's simply impossible, like
  propagated text-decorations we can't remove) is that we don't try to override
  !important rules from external stylesheets, although we also don't go out of
  our way to respect them.

  <li>When we're given a presentational command like "bold", don't modify
  anything other than presentational markup related to that command.  If an
  element has non-presentational attributes like id or class, don't split it up
  or remove it or anything.  At most convert it to a span, if it's some type of
  presentational element (where "presentational" here really means "browsers
  produce it in response to execCommand() so we need to treat it as
  presentational", so it includes things like [[strong]] and [[em]]).

  <li>Don't interfere with more markup than necessary.  If the user modifies
  only a small run of text, don't go around simplifying ancestors or siblings
  or whatever unless it's necessary to produce simpler markup in the place that
  was actually modified.

  <li>But if we are already changing around something's style, convert existing
  styles to the preferred format.  For instance, we use [[b]] for bold, and
  convert [[strong]] and &lt;[[span]] [[style]]="font-weight: bold"> if we
  happen to be modifying that node anyway.

  <li>Try not to make the document less conforming than it originally was.  If
  we happen to make it more conforming, good, although we don't have to go out
  of our way to do that.  In some cases we do make the document less
  conforming, generally because there's some clear use-case that requires it or
  because it matches existing browsers behavior.  (For instance, see the
  <code title=command-stylewithcss>styleWithCSS</code> = false mode, and the
  fact that <code title=command-insertimage>insertImage</code> doesn't add an
  alt attribute, and how list-related commands can make list elements nested in
  one another directly without intervening &lt;li>, etc.)

  <li>Keep the markup as concise as possible.  (I've received feedback that
  this is very important to authors.)  Ideally, the markup should look as
  simple and neat as what a human would have produced by hand-editing.  We do
  complicated manipulation to pull styles down from ancestors rather than
  having to use inline CSS, and make sure to tidy up any styles on elements
  that we happen to be modifying anyway.  Previous principles take precedence
  over this one, however.

  <li>I'm generally ignoring the existence of processing instructions, so
  they'll be treated more or less randomly.  (I'm ensuring that behavior is
  well-defined, I just don't care what it is.)  Comments are also unlikely to
  occur much for our purposes, but I try a little harder to make them behave
  not too unreasonably.
</ul>


<h2>Issues</h2>

<p>This specification is very preliminary, and should not be used for anything
other than review and comment.

<ul>
  <li>Need to make CSS terminology more precise, about setting/unsetting CSS
  properties.  The intent is to modify the style attribute, CSSOM-style.
  Likewise, CSS value comparisons need to be done after serializing both
  values, so "bold" == "700" and "red" == "#f00" and so on.

  <li>Also not sure about computed style.  There are differences between
  "computed" and "used" and things like that, what do we actually want here?

  <li>The wording I use for DOM stuff is not maximally precise.  Really I want
  DOM Core to define nice concepts that I can xref, like "insert a node".  I
  don't want to have to explicitly refer to DOM methods like insertBefore()
  every time I want to move things.

  <li>Some more thought needs to go into what happens to the selection when you
  mutate the DOM.  In some cases the results are pretty arbitrary.  It might
  make sense to do some kind of normalization.

  <li>JavaScript can modify the DOM synchronously in some cases, such as DOM
  mutation events and onunload when moving around iframes and objects.  This
  has to be dealt with somehow.  (Pointed out by Ryosuke Niwa of WebKit: <a
  href=http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2011-March/030730.html>1</a>
  <a href=http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2011-March/030751.html>2</a>)

  <li>I'm sloppy about handling things like nodes that don't descend from a
  Document, comments that are children of a Document, that sort of thing.  Not
  essential for prototyping, but needs to be cleaned up eventually.  Mostly we
  should be able to avoid the problems by requiring that everything be
  editable, since that immediately means it has to descend from an element or
  Document (and cannot be parentless itself).

  <li>I haven't paid much attention to performance.  The algorithms here aren't
  performance-critical in most cases, but I might have accidentally included
  some algorithms that are too slow anyway on large pages.  Generally I haven't
  worried about throwing nodes away and recreating them multiple times or
  things like that, as long as it produces the correct result.

  <li>I need to pay more attention to whitespace-only nodes.  In most cases
  these will have no visual effect, but they'll make many algorithms behave
  differently: decomposing a range, block-extending, etc.  In at least some
  cases, it's not even possible for the cursor to wind up in them, so maybe we
  don't need to bother marking them up or anything.

  <li>Tim Down <a href="http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2011-May/031655.html">points
  out</a> that browsers have special behavior for formatting commands when the
  selection is collapsed.  Needs investigation.

  <li>What should be used as a line separator?  See <a
  href=http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2011-May/031577.html>lengthy
  discussion</a>.  I see no strong arguments in favor of any of the three
  existing behaviors, so I'm weakly in favor of following the plurality, namely
  IE/Opera's behavior of using [[p]].  This affects not only what happens when
  the user hits Enter, but also what happens when we need to separate lines for
  other reasons (e.g., outdenting a list).  We likely want switches to allow
  authors to control this behavior, like Gecko's insertBrOnReturn and Opera's
  opera-defaultblock.  Currently the spec assumes [[br]] should separate lines,
  which is like Gecko and sometimes WebKit.
</ul>

<p class=XXX>A variety of other issues are also noted in the text, formatted
like this.


<h2>Definitions</h2>

<p>An <dfn>HTML element</dfn> is an [[element]] whose [[namespace]] is the
[[htmlnamespace]].

<p>An <dfn>inline node</dfn> is either a [[text]] node, or an [[element]] whose
"display" property computes to "inline", "inline-block", or "inline-table".

<p>To <dfn>set the tag name</dfn> of an [[element]] <var>element</var> to
<var>new name</var>, the user agent must run the following steps:

<ol>
  <li>If <var>element</var> is an <span>HTML element</span> with [[localname]]
  equal to <var>new name</var>, return <var>element</var>.

  <li>If <var>element</var>'s [[parent]] is null, return <var>element</var>.

  <li>Let <var>replacement element</var> be the result of calling <code
  data-anolis-spec=domcore
  title=dom-Document-createElement>createElement(<var>new name</var>)</code> on
  the [[ownerdocument]] of <var>element</var>.

  <li>Insert <var>replacement element</var> into <var>element</var>'s
  [[parent]] immediately before <var>element</var>.

  <li>Copy all attributes of <var>element</var> to <var>replacement
  element</var>, in order.

  <li>While <var>element</var> has [[children]], append the first [[child]] of
  <var>element</var> as the last [[child]] of <var>replacement element</var>,
  <span>preserving ranges</span>.

  <li>Remove <var>element</var> from its [[parent]].

  <li>Return <var>replacement element</var>.
</ol>

<p>To remove a [[node]] <var>node</var> while <dfn>preserving its
descendants</dfn>:

<ol>
  <li>Let <var>children</var> be a list of <var>node</var>'s [[children]].

  <li>If <var>node</var>'s [[parent]] is null, remove all of <var>node</var>'s
  [[children]] from <var>node</var>, then return <var>children</var>.

  <li><span>Remove extraneous line breaks</span> from <var>node</var>.

  <li>If <var>node</var> is not an <span>inline node</span>, and its first
  [[child]] and [[previoussibling]] are both <span title="inline node">inline
  nodes</span>, and the first [[child]] of <var>node</var> is not a [[br]],
  call <code data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("br")</code> on the
  [[ownerdocument]] of <var>node</var>, and insert the result into
  <var>node</var>'s [[parent]] immediately before <var>node</var>.

  <li>While <var>node</var> has [[children]], insert the first [[child]] of
  <var>node</var> into <var>node</var>'s [[parent]] immediately before
  <var>node</var>, <span>preserving ranges</span>.

  <li>If <var>node</var> is not an <span>inline node</span>, and its
  [[previoussibling]] and [[nextsibling]] are both <span title="inline
  node">inline nodes</span> but neither is a [[br]], call <code
  data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("br")</code> on the
  [[ownerdocument]] of <var>node</var>, and insert the result into
  <var>node</var>'s [[parent]] immediately before <var>node</var>.

  <li>Remove <var>node</var> from its [[parent]].

  <li>Return <var>children</var>.
</ol>

<p>To <dfn>split the parent</dfn> of a list <var>node list</var> of consecutive
[[sibling]] [[nodes]]:

<ol>
  <li>Let <var>original parent</var> be the [[parent]] of the first member of
  <var>node list</var>.

  <li>If <var>original parent</var> is not <span>editable</span> or its
  [[parent]] is null, do nothing and abort these steps.

  <li>If the [[previoussibling]] of the first member of <var>node list</var> is
  not null, and the [[nextsibling]] of the last member of <var>node list</var>
  is null:

  <div class=XXX>
  <p>We insert things after the parent.  This is bad, because it will cause
  them to become part of any ranges that immediately follow.  For instance, if
  we're hitting "bar" in

  <xmp><div><p>foo<p>bar</div>{<p>baz}</xmp>

  <p>it becomes

  <xmp><div><p>foo</div>{<p>bar<p>baz}</xmp>

  <p>instead of

  <xmp><div><p>foo</div><p>bar{<p>baz}</xmp>

  <p>because of how range mutation rules work.  This doesn't happen if we
  insert before.  Probably this isn't important enough to try working around,
  though.
  </div>

  <ol>
    <li>If the last member of <var>node list</var> and the [[nextsibling]] of
    <var>original parent</var> are both <span title="inline node">inline
    nodes</span>, call <code data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("br")</code> on the
    [[ownerdocument]] of <var>original parent</var>, then insert the result
    into the [[parent]] of <var>original parent</var> immediately after
    <var>original parent</var>.

    <li>For each <var>node</var> in <var>node list</var>, <em>in reverse
    order</em>, insert <var>node</var> into the [[parent]] of <var>original
    parent</var> immediately after <var>original parent</var>, <span>preserving
    ranges</span>.

    <li>Abort these steps.
  </ol>

  <li>If the [[previoussibling]] of the first member of <var>node list</var> is
  not null:

  <ol>
    <li>Let <var>cloned parent</var> be the result of calling <code
    data-anolis-spec=domcore title=dom-Node-cloneNode>cloneNode(false)</code>
    on <var>original parent</var>.

    <p class=XXX>This will duplicate id's, as well as other bad things.  Do we
    care?  We don't want to not copy attributes at all, because that wouldn't
    copy style attributes, and Firefox in CSS mode will actually add style
    attributes to any elements it feels like.  If we do exclude id's, even
    though they'd only occur if someone manually added them, do we want to
    exclude other things like itemid or accesskey or . . .

    <li>Insert <var>cloned parent</var> into the [[parent]] of <var>original
    parent</var> immediately before <var>original parent</var>.

    <li>While the [[previoussibling]] of the first member of <var>node
    list</var> is not null, append the first [[child]] of <var>original
    parent</var> as the last [[child]] of <var>cloned parent</var>,
    <span>preserving ranges</span>.
  </ol>

  <li>If the first member of <var>node list</var> and the [[previoussibling]]
  of <var>original parent</var> are both <span title="inline node">inline
  nodes</span>, call <code data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("br")</code> on the
  [[ownerdocument]] of <var>original parent</var>, then insert the result into
  the [[parent]] of <var>original parent</var> immediately before <var>original
  parent</var>.

  <li>For each <var>node</var> in <var>node list</var>, insert <var>node</var>
  into the [[parent]] of <var>original parent</var> immediately before
  <var>original parent</var>, <span>preserving ranges</span>.
</ol>

<p>To <dfn>wrap</dfn> a list <var>node list</var> of consecutive [[sibling]]
[[nodes]], given <dfn>sibling criteria</dfn> and <dfn>new parent
instructions</dfn>:

<ol>
  <li>If <var>node list</var> is empty, or the first member of <var>node
  list</var> is not <span>editable</span>, abort these steps.

  <li>If the [[previoussibling]] of the first member of <var>node list</var>
  is <span>editable</span> and meets the <span>sibling criteria</span>, then
  for each <var>node</var> in <var>node list</var>, append <var>node</var> as
  the last [[child]] of its [[previoussibling]], <span>preserving
  ranges</span>.  Then abort these steps.

  <li>If the [[nextsibling]] of the last member of <var>node list</var> is
  <span>editable</span> and meets the <span>sibling criteria</span>, then for
  each <var>node</var> in <var>node list</var>, <em>in reverse order</em>,
  insert <var>node</var> as the first [[child]] of its [[nextsibling]],
  <span>preserving ranges</span>.  Then abort these steps.

  <li>Run the <span>new parent instructions</span>, and let <var>new
  parent</var> be the result.

  <li>If <var>new parent</var> cannot be the [[child]] of the [[parent]] of the
  first member of <var>node list</var>, <span>split the parent</span> of
  <var>node list</var>.

  <p class=XXX>"Cannot be the child" needs to be defined.

  <li>Insert <var>new parent</var> into the [[parent]] of the first member of
  <var>node list</var> immediately before the first member of <var>node
  list</var>.

  <li>For each <var>node</var> in <var>node list</var>, append <var>node</var>
  as the last [[child]] of <var>new parent</var>, <span>preserving
  ranges</span>.

  <li><span>Remove extraneous line breaks</span> from <var>new parent</var>.
</ol>

<p>To <dfn>remove extraneous line breaks</dfn> from a [[node]] <var>node</var>:

<ol>
  <li>If <var>node</var> is not an [[element]], or it is an <span>inline
  node</span>, do nothing and abort these steps.

  <li>If the [[previoussibling]] of <var>node</var> is a [[br]], and the
  [[previoussibling]] of the [[previoussibling]] of <var>node</var> is an
  <span>inline node</span> that is not a [[br]], remove the [[previoussibling]]
  of <var>node</var> from its [[parent]].

  <li>If <var>node</var> has at least two [[children]], and its last [[child]]
  is a [[br]], and its second-to-last [[child]] is an <span>inline node</span>
  that is not a [[br]], remove the last [[child]] of <var>node</var> from
  <var>node</var>.
</ol>

<p>An <dfn>editing host</dfn> is a [[node]] that is either an [[element]] with
a <code data-anolis-spec=html title=attr-contenteditable>contenteditable</code>
attribute set to the true state, or a [[document]] whose <code
data-anolis-spec=html>designMode</code> is enabled.

<p>Something is <dfn>editable</dfn> if it is a [[node]] which is not an
<span>editing host</span>, does not have a <code data-anolis-spec=html
title=attr-contenteditable>contenteditable</code> attribute set to the false
state, and whose [[parent]] is an <span>editing host</span> or
<span>editable</span>.

<p class=note>The algorithms here will generally not remove or alter the
attributes of any node that is not editable.  Note that an editing host is not
editable, so authors are assured that editing commands will only modify the
editing host's contents and not the editing host itself.

<p>A [[node]] is <dfn>effectively contained</dfn> in a [[range]] if either it
is [[contained]] in the [[range]]; or it is the [[range]]'s [[rangestart]]
[[bpnode]], it is a [[text]] node, and its [[nodelength]] is different from the
[[range]]'s [[rangestart]] [[bpoffset]]; or it is the [[range]]'s [[rangeend]]
[[bpnode]], it is a [[text]] node, and the [[range]]'s [[rangeend]]
[[bpoffset]] is not 0; or it has at least one [[child]], and all its
[[children]] are <span>effectively contained</span> in the [[range]].
<!-- Logically, the effectively contained nodes are supposed to be the ones
returned by decomposing the range, or their descendants.  We can't actually
define it that way, because decomposing the range has side effects (calling
splitText()), and anyway text nodes might not be returned by decomposing even
if they're effectively contained: it might be that the new node created by
splitText() is returned. -->

<p>An <dfn>unwrappable node</dfn> is an <span>HTML element</span> which may not
be used where only [[phrasingcontent]] is expected (not counting unknown or
obsolete elements, which cannot be used at all); or any [[element]] whose
display property computes to something other than "inline", "inline-block", or
"inline-table"; or any [[node]] that is not <span>editable</span>.

<p class=XXX>Currently when we hit an unwrappable element, we ignore it and
alter its children.  Alternatively, if we would otherwise create a span with a
style element on it, maybe we could put the style element directly on the
unwrappable element.  This would produce shorter markup in many cases, but
would also cause problems for things like background-color that do something
different on block elements.

<p>The <dfn>effective value</dfn> of a [[node]] <var>node</var> for a given
<var>command</var> is returned by the following algorithm, which will return
either a string or null:

<ol>
  <li>If neither <var>node</var> nor its [[parent]] is an [[element]], return
  null.

  <li>If <var>node</var> is not an [[element]], return the <span>effective
  value</span> of its [[parent]] for <var>command</var>.

  <li>If <var>command</var> is "createLink" or "unlink":

  <ol>
    <li>While <var>node</var> is not null, and is not an [[a]] element that has
    an [[href]] attribute, set <var>node</var> to its [[parent]].

    <li>If <var>node</var> is null, return null.

    <li>Return the [[attrvalue]] of <var>node</var>'s [[href]] attribute.
  </ol>

  <li>If <var>command</var> is "hiliteColor":

  <ol>
    <li>While the computed style of "background-color" on <var>node</var> is
    any fully transparent value, and <var>node</var>'s [[parent]] is an
    [[element]], set <var>node</var> to its [[parent]].

    <li>If the computed style of "background-color" on <var>node</var> is
    a fully transparent value, return "rgb(255, 255, 255)".

    <li>Otherwise, return the computed style of "background-color" for
    <var>node</var>.
  </ol>

  <li>If <var>command</var> is "subscript" or "superscript":

  <ol>
    <li>Let <var>affected by subscript</var> and <var>affected by
    superscript</var> be two boolean variables, both initially false.

    <li>While <var>node</var> is an [[element]] whose "display" property
    computes to "inline":

    <ol>
      <li>If <var>node</var>'s "vertical-align" property computes to "sub", set
      <var>affected by subscript</var> to true.

      <li>Otherwise, if <var>node</var>'s "vertical-align" property computes to
      "super", set <var>affected by superscript</var> to true.

      <li>Otherwise, if <var>node</var>'s "vertical-align" property computes to
      some value other than "baseline", return the string "mixed".

      <li>Set <var>node</var> to its [[parent]].
    </ol>

    <li>If <var>affected by subscript</var> and <var>affected by
    superscript</var> are both true, return the string "mixed".

    <li>If <var>affected by subscript</var> is true, return "sub".

    <li>If <var>affected by superscript</var> is true, return "super".

    <li>Return "baseline".
  </ol>

  <li>If <var>command</var> is "strikethrough", and the "text-decoration"
  property of <var>node</var> or any of its [[ancestors]] computes to
  a value containing "line-through", return "line-through".  Otherwise, return
  null.

  <li>If <var>command</var> is "underline", and the "text-decoration"
  property of <var>node</var> or any of its [[ancestors]] computes to
  a value containing "underline", return "underline".  Otherwise, return
  null.

  <li>Return the computed style for <var>node</var> of the <span>relevant CSS
  property</span> for <var>command</var>.
</ol>

<p>The <dfn>specified value</dfn> of an [[element]] <var>element</var> for a
given <var>command</var> is returned by the following algorithm, which will
return either a string or null:

<p class=XXX>"Specified value" already means something in CSS, I need to find a
different name.

<ol>
  <li>If <var>command</var> is "hiliteColor" and the [[element]]'s
  display property does not compute to "inline", return null.

  <li>If <var>command</var> is "createLink" or "unlink":

  <ol>
    <li>If <var>element</var> is an [[a]] element and has an [[href]]
    attribute, return the [[attrvalue]] of that attribute.

    <li>Return null.
  </ol>

  <li>If <var>command</var> is "subscript" or "superscript":

  <ol>
    <li>If the computed value of <var>element</var>'s "display" property is
    neither "inline" nor "inline-block" nor "inline-table", return null.

    <li>If <var>element</var> has a [[style]] attribute set, and that attribute
    has the effect of setting "vertical-align", return the value that it sets
    "vertical-align" to.

    <li>If <var>element</var> is a [[sup]], return "super".

    <li>If <var>element</var> is a [[sub]], return "sub".

    <li>Return null.
  </ol>

  <li>If <var>command</var> is "strikethrough", and <var>element</var> has a
  [[style]] attribute set, and that attribute sets "text-decoration":

  <ol>
    <li>If <var>element</var>'s [[style]] attribute sets "text-decoration" to a
    value containing "line-through", return "line-through".

    <li>Return null.
  </ol>

  <li>If <var>command</var> is "strikethrough" and <var>element</var> is an
  [[s]] or [[strike]] element, return "line-through".

  <li>If <var>command</var> is "underline", and <var>element</var> has a
  [[style]] attribute set, and that attribute sets "text-decoration":

  <ol>
    <li>If <var>element</var>'s [[style]] attribute sets "text-decoration" to a
    value containing "underline", return "underline".

    <li>Return null.
  </ol>

  <li>If <var>command</var> is "underline" and <var>element</var> is a [[u]]
  element, return "underline".

  <li>Let <var>property</var> be the <span>relevant CSS property</span> for
  <var>command</var>.

  <li>If <var>property</var> is null, return null.

  <li>If <var>element</var> has a [[style]] attribute set, and that attribute has
  the effect of setting <var>property</var>, return the value that it sets
  <var>property</var> to.

  <li>If <var>element</var> is a [[font]] element that has an attribute whose
  effect is to create a [[presentationalhint]] for <var>property</var>, return
  the value that the hint sets <var>property</var> to.  (For a [[fontsize]] of
  7, this will be the non-CSS value "xxx-large".)

  <li>If <var>element</var> is in the following list, and <var>property</var> is
  equal to the CSS property name listed for it, return the string listed for
  it.

  <dl class=switch>
    <dt>[[b]]
    <dt>[[strong]]
    <dd>font-weight: "bold"

    <dt>[[i]]
    <dt>[[em]]
    <dd>font-style: "italic"
  </dl>

  <li>Return null.
</ol>

<p>A <dfn>modifiable element</dfn> is a [[b]], [[em]], [[i]], [[s]], [[span]],
[[strike]], [[strong]], [[sub]], [[sup]], or [[u]] element with no attributes
except possibly [[style]]; or a [[font]] element with no attributes except
possibly [[style]], [[fontcolor]], [[fontface]], and/or [[fontsize]]; or an
[[a]] element with no attributes except possibly [[style]] and/or [[href]].

<p>A <dfn>simple modifiable element</dfn> is an <span>HTML element</span> for
which at least one of the following holds:

<ul>
  <li>It is an [[a]], [[b]], [[em]], [[font]], [[i]], [[s]], [[span]],
  [[strike]], [[strong]], [[sub]], [[sup]], or [[u]] element with no
  attributes.

  <li>It is an [[a]], [[b]], [[em]], [[font]], [[i]], [[s]], [[span]],
  [[strike]], [[strong]], [[sub]], [[sup]], or [[u]] element with exactly one
  attribute, which is [[style]], which sets no CSS properties (including
  invalid or unrecognized properties).

  <li>It is an [[a]] element with exactly one attribute, which is [[href]].

  <li>It is a [[font]] element with exactly one attribute, which is either
  [[fontcolor]], [[fontface]], or [[fontsize]].

  <li>It is a [[b]] or [[strong]] element with exactly one attribute, which is
  [[style]], and the [[style]] attribute sets exactly one CSS property
  (including invalid or unrecognized properties), which is "font-weight".

  <li>It is an [[i]] or [[em]] element with exactly one attribute, which is
  [[style]], and the [[style]] attribute sets exactly one CSS property
  (including invalid or unrecognized properties), which is "font-style".

  <li>It is a [[sub]] or [[sup]] element with exactly one attribute, which is
  [[style]], and the [[style]] attribute sets exactly one CSS property
  (including invalid or unrecognized properties), which is "vertical-align".

  <li>It is an [[a]], [[font]], or [[span]] element with exactly one attribute,
  which is [[style]], and the [[style]] attribute sets exactly one CSS property
  (including invalid or unrecognized properties), and that property is not
  "text-decoration".

  <li>It is an [[a]], [[font]], [[s]], [[span]], [[strike]], or [[u]] element
  with exactly one attribute, which is [[style]], and the [[style]] attribute
  sets exactly one CSS property (including invalid or unrecognized properties),
  which is "text-decoration", which is set to "line-through" or "underline" or
  "overline" or "none".
</ul>

<p class=note>Conceptually, a simple modifiable element is a modifiable element
which <span title="specified value">specifies</span> a value for at most one
command.

<p>When the user agent is to move a [[node]] to a new location, <dfn>preserving
ranges</dfn>, it must remove the [[node]] from its original [[parent]] (if
any), then insert it in the new location.  In doing so, however, it must ignore
the regular [[rangemutationrules]], and instead follow these rules:

<ol>
  <li>Let <var>node</var> be the moved [[node]], <var>old parent</var> and
  <var>old index</var> be the old [[parent]] (which may be null) and [[index]],
  and <var>new parent</var> and <var>new index</var> be the new [[parent]] and
  [[index]].

  <li>If a [[boundarypoint]]'s [[bpnode]] is the same as or a [[descendant]] of
  <var>node</var>, leave it unchanged, so it moves to the new location.  <!--
  This is actually implicit, but I state it anyway for completeness. -->

  <li>If a [[boundarypoint]]'s [[bpnode]] is <var>new parent</var> and its
  [[bpoffset]] is greater than <var>new index</var>, add one to its
  [[bpoffset]].

  <li>If a [[boundarypoint]]'s [[bpnode]] is <var>old parent</var> and its
  [[bpoffset]] is <var>old index</var> or <var>old index</var> + 1, set its
  [[bpnode]] to <var>new parent</var> and add <var>new index</var> &minus;
  <var>old index</var> to its [[bpoffset]].

  <li>If a [[boundarypoint]]'s [[bpnode]] is <var>old parent</var> and its
  [[bpoffset]] is greater than <var>old index</var> + 1, subtract one from its
  [[bpoffset]].
</ol>

<p>The <dfn>CSS styling flag</dfn> is a boolean flag, which must initially be
false.

<p class=XXX>Is the styling flag associated with the document, with the editing
host, what?  Needs reverse-engineering.

<p>When the user agent is instructed to run a particular method, it must follow
the steps defined for that method in the appropriate specification, not act as
though the method had actually been called from JavaScript.  In particular,
if the author has overridden the method with a custom method, the standard
method must be run rather than the custom one.

<p>When a list or set of [[nodes]] is assigned to a variable without specifying
the order, they must be initially in [[treeorder]], if they share a root.
(If they don't share a root, the order will be specified.)  When the user agent
is instructed to run particular steps for each member of a list, it must do so
sequentially in the list's order.


<h2>Decomposing a range into nodes</h2>
<p>When a user agent is to <dfn>decompose</dfn> a [[range]] <var>range</var>,
it must run the following steps.

<p class=note>For this algorithm to be correct, it is essential that user
agents follow the [[rangemutationrules]], particularly those for <code
title>splitText()</code>.

<ol>
  <li>If <var>range</var>'s [[rangestart]] and [[rangeend]] are the same,
  return an empty list.

  <li>If <var>range</var>'s [[rangestart]] [[bpnode]] is a [[text]] node and
  its [[rangestart]] [[bpoffset]] is neither 0 nor the [[nodelength]] of its
  [[rangestart]] [[bpnode]], run <code data-anolis-spec=domcore
  title=dom-Text-splitText>splitText()</code> on its [[rangestart]] [[bpnode]]
  with argument equal to its [[rangestart]] [[bpoffset]].

  <li>If <var>range</var>'s [[rangeend]] [[bpnode]] is a [[text]] node and
  its [[rangeend]] [[bpoffset]] is neither 0 nor the [[nodelength]] of its
  [[rangeend]] [[bpnode]], run <code data-anolis-spec=domcore
  title=dom-Text-splitText>splitText()</code> on its [[rangeend]] [[bpnode]]
  with argument equal to its [[rangeend]] [[bpoffset]].

  <!-- Now we want to make sure our range contains as many nodes as possible,
  such as by changing <tag>[foo]</tag> to {<tag>foo</tag>}. -->
  <li>Let <var>cloned range</var> be the result of calling <code
  data-anolis-spec=domrange title=dom-Range-cloneRange>cloneRange()</code> on
  <var>range</var>.

  <li>While the [[rangestart]] [[bpoffset]] of <var>cloned range</var> is 0,
  and the [[parent]] of <var>cloned range</var>'s [[rangestart]] [[bpnode]] is
  not null, set the [[rangestart]] of <var>cloned range</var> to ([[parent]] of
  [[rangestart]] [[bpnode]], [[index]] of [[rangestart]] [[bpnode]]).

  <li>While the [[rangeend]] [[bpoffset]] of <var>cloned range</var> equals the
  [[nodelength]] of its [[rangeend]] [[bpnode]], and the [[parent]] of
  <var>clone range</var>'s [[rangeend]] [[bpnode]] is not null, set the
  [[rangeend]] of <var>cloned range</var> to ([[parent]] of [[rangeend]]
  [[bpnode]], 1 + [[index]] of [[rangeend]] [[bpnode]]).

  <li>Return a list consisting of every [[node]] [[contained]] in <var>cloned
  range</var> in [[treeorder]], omitting any whose [[parent]] is also
  [[contained]] in <var>cloned range</var>.
</ol>


<h2>Normalizing sublists of a list item</h2>
<p>When a user agent is to <dfn>normalize sublists</dfn> in a [[node]]
<var>item</var>, it must run the following steps:
<!--
This algorithm implies that we don't support a sublist in the middle of an
item, only at the end.  For instance,

  <li>foo<ol>...</ol>bar</li>

gets transformed to

  <li>foo</li><ol>...</ol><li>bar</li>

which in particular creates an extra list marker for "bar".  This is okay; we
don't need to expose all of HTML's markup abilities through execCommand().
Similarly, the superscript and subscript commands don't allow nesting.  I
didn't see any way to get a sublist in the middle of an item in Word 2007 or in
OpenOffice.org 3.2.1 Ubuntu package, nor in  any browser using just
execCommand(), so it should be no big problem if we require that such nesting
not occur.  (Existing browsers behave weirdly and inconsistently when
confronted with this kind of nesting.)
-->

<ol>
  <li>If <var>item</var> is not an [[li]] or it is not <span>editable</span> or
  its [[parent]] is not <span>editable</span>, abort these steps.

  <li>Let <var>new item</var> be null.

  <li>While <var>item</var> has an [[ol]] or [[ul]] [[child]]:

  <ol>
    <li>Let <var>child</var> be the last [[child]] of <var>item</var>.

    <li>If <var>child</var> is an [[ol]] or [[ul]], or <var>new item</var> is
    null and <var>child</var> is a [[text]] node whose <code
    data-anolis-spec=domcore title=dom-CharacterData-data>data</code>
    consists of zero of more <span data-anolis-spec=domcore title="space
    character">space characters</span>:

    <ol>
      <li>Set <var>new item</var> to null.

      <li>Insert <var>child</var> into the [[parent]] of <var>item</var>
      immediately following <var>item</var>, <span>preserving ranges</span>.
    </ol>

    <li>Otherwise:

    <ol>
      <li>If <var>new item</var> is null, let <var>new item</var> be the
      result of calling <code data-anolis-spec=domcore
      title=dom-Document-createElement>createElement("li")</code> on the
      [[ownerdocument]] of <var>item</var>, then insert <var>new item</var>
      into the [[parent]] of <var>item</var> immediately after
      <var>item</var>.

      <li>Insert <var>child</var> into <var>new item</var> as its first
      [[child]], <span>preserving ranges</span>.
    </ol>
  </ol>
</ol>

<h2>Block-extending a range</h2>
<p>When a user agent is to <dfn>block-extend</dfn> a [[range]]
<var>range</var>, it must run the following steps:

<ol>
  <li>Let <var>start node</var>, <var>start offset</var>, <var>end node</var>,
  and <var>end offset</var> be the [[rangestart]] and [[rangeend]] [[bpnodes]]
  and [[bpoffsets]] of <var>range</var>.

  <li>If some [[ancestorcontainer]] of <var>start node</var> is an [[li]], set
  <var>start offset</var> to the [[index]] of the last such [[li]] in
  [[treeorder]], and set <var>start node</var> to that [[li]]'s [[parent]].

  <li>Repeat the following steps:

  <ol>
    <li>If <var>start node</var> is a [[text]] or [[comment]] node or
    <var>start offset</var> is 0, set <var>start offset</var> to the [[index]]
    of <var>start node</var> and then set <var>start node</var> to its
    [[parent]].

    <li>Otherwise, if <var>start offset</var> is equal to the
    [[nodelength]] of <var>start node</var>, set <var>start offset</var> to one
    plus the [[index]] of <var>start node</var> and then set <var>start
    node</var> to its [[parent]].

    <li>Otherwise, if the [[child]] of <var>start node</var> with [[index]]
    <var>start offset</var> and its [[previoussibling]] are both <span
    title="inline node">inline nodes</span> and the [[previoussibling]] isn't a
    [[br]], subtract one from <var>start offset</var>.
    <!-- IE also includes <br> (at least for the purposes of the indent
    command), but this is unlikely to match user expectations. -->

    <p class=XXX>This is wrong in the presence of comments or display: none or
    probably other things.  Do we care?

    <li>Otherwise, break from this loop.
  </ol>

  <li>If some [[ancestorcontainer]] of <var>end node</var> is an [[li]], set
  <var>end offset</var> to one plus the [[index]] of the last such [[li]] in
  [[treeorder]], and set <var>end node</var> to that [[li]]'s [[parent]].

  <li>Repeat the following steps:

  <ol>
    <li>If <var>end offset</var> is 0, set <var>end offset</var> to the
    [[index]] of <var>end node</var> and then set <var>end node</var> to its
    [[parent]].

    <li>Otherwise, if <var>end node</var> is a [[text]] or [[comment]] node or
    <var>end offset</var> is equal to the [[nodelength]] of <var>end
    node</var>, set <var>end offset</var> to one plus the [[index]] of <var>end
    node</var> and then set <var>end node</var> to its [[parent]].

    <li>Otherwise, if the [[child]] of <var>end node</var> with [[index]]
    <var>end offset</var> and its [[previoussibling]] are both <span
    title="inline node">inline nodes</span>, and the [[child]] of <var>end
    node</var> with [[index]] <var>end offset</var> isn't a [[br]], add one to
    <var>end offset</var>.

    <li>Otherwise, break from this loop.
  </ol>

  <li>If the [[child]] of <var>end node</var> with [[index]] <var>end
  offset</var> is a [[br]], add one to <var>end offset</var>.

  <li>While <var>end offset</var> is equal to the [[nodelength]] of <var>end
  node</var>, set <var>end offset</var> to one plus the [[index]] of <var>end
  node</var> and then set <var>end node</var> to its [[parent]].

  <li>Let <var>new range</var> be a new [[range]] whose [[rangestart]] and
  [[rangeend]] [[bpnodes]] and [[bpoffsets]] are <var>start node</var>,
  <var>start offset</var>, <var>end node</var>, and <var>end offset</var>.

  <li>Return <var>new range</var>.
</ol>


<h2>Clearing an element's value</h2>
<p>When a user agent is to <dfn>clear the value</dfn> of an element
<var>element</var>, it must run the following steps:

<p class=note>Clearing the value of an element can remove it from its parent
and put other nodes in its place.  When implementations do something like clear
the value of all children of an element, they should take care not to assume
that the set of children won't change as they're cleared.  If the element is
removed, the algorithm will return the list of nodes inserted in its place.

<!-- If we wanted to be extra-pedantic, we could convert, e.g., <font color=red
id=foo> into <span id=foo> instead of <font id=foo>, but probably not worth it.
-->

<ol>
  <li>If <var>element</var>'s <span>specified value</span> for
  <var>command</var> is null, return the empty list.  <!-- We want to abort
  early so that we don't try unsetting background-color on a non-inline
  element. -->

  <li>If <var>element</var> is a <span>simple modifiable element</span>:

  <ol>
    <li>Let <var>children</var> be the [[children]] of <var>element</var>.

    <li>While <var>element</var> has [[children]], insert its first [[child]]
    into its [[parent]] immediately before it, <span>preserving ranges</span>.

    <li>Remove <var>element</var> from its [[parent]].
    <!-- Notice that a boundary point that was immediately before or after the
    element will now be immediately before or after its children, just because
    of the regular range mutation rules, without needing to worry about
    preserving ranges.  Preserving ranges is only necessary for the sake of
    boundary points in the element or its descendants. -->

    <li>Return <var>children</var>.
  </ol>

  <li>If <var>command</var> is "strikethrough", and <var>element</var> has a
  [[style]] attribute that sets "text-decoration" to some value containing
  "line-through", delete "line-through" from the value.

  <li>If <var>command</var> is "underline", and <var>element</var> has a
  [[style]] attribute that sets "text-decoration" to some value containing
  "underline", delete "underline" from the value.

  <li>If the <span>relevant CSS property</span> for <var>command</var> is not
  null, unset that property of <var>element</var>.

  <li>If <var>element</var> is a [[font]] element:

  <ol>
    <li>If <var>command</var> is "foreColor", unset <var>element</var>'s
    [[fontcolor]] attribute, if set.

    <li>If <var>command</var> is "fontName", unset <var>element</var>'s
    [[fontface]] attribute, if set.

    <li>If <var>command</var> is "fontSize", unset <var>element</var>'s
    [[fontsize]] attribute, if set.
  </ol>

  <li>If <var>element</var> is an [[a]] element and <var>command</var> is
  "createLink" or "unlink", unset the [[href]] property of <var>element</var>.

  <li>If <var>element</var>'s <span>specified value</span> for
  <var>command</var> is null, return the empty list.
  <!-- If we get past this step, we're something like <b class=foo> where we
  want to keep the extra attributes, so we stick them on a span. -->

  <li>Let <var>new element</var> be a new <span>HTML element</span> with
  [[localname]] "span", with the same attributes and [[ownerdocument]] as
  <var>element</var>.

  <li>Insert <var>new element</var> into the [[parent]] of <var>element</var>
  immediately before it.
  <!-- This means that the boundary point immediately before the element goes
  before the new element, and after we remove the old element, the boundary
  point immediately after the old element will be immediately after the new
  element, because of the regular range mutation rules. -->

  <li>While <var>element</var> has [[children]], append its first [[child]] as
  the last [[child]] of <var>new element</var>, <span>preserving ranges</span>.

  <li>Remove <var>element</var> from its [[parent]].

  <li>Return the one-[[node]] list consisting of <var>new element</var>.
</ol>


<h2>Pushing down values</h2>
<p>When a user agent is to <dfn>push down values</dfn> to a [[node]]
<var>node</var>, given a command <var>command</var> and a new value
<var>new value</var>, it must run the following steps:

<div class=XXX>
<p>This algorithm goes up to just below the nearest ancestor with the right
style, then re-applies the bad styles repeatedly going down, omitting the
things we want to have the new style.  This is basically what WebKit does,
although WebKit sometimes starts higher up and therefore makes more intrusive
changes, often creating more markup.  IE follows the same general approach too.

<p>Gecko instead seems to start breaking up elements from the bottom, so that the
range consists of a few consecutive siblings, and it can then break up the
problematic element into a maximum of two pieces.  The spec's approach seems to
create fewer elements and simpler markup (or at least markup that's no more
complex) in most cases I throw at it.

<p>Gecko's approach does have the major advantage that it gets underlines right in
many cases for free.  E.g.,

<xmp>  <u>foo<font color=red>[bar]baz</font></u>
  -> <u>foo</u><font color=red>bar<u>baz</u></font> (spec)
  -> <u>foo</u><font color=red>bar</font><u><font color=red>baz</font></u> (Gecko)</xmp>

<p>The spec's markup here is much shorter and contains fewer elements, but is
wrong: the underline under "baz" has changed color from black to red.  It might
be worth trying to copy Gecko's results in such cases, but that won't solve all
underline problems, so perhaps it's not worth it.

<p>Opera also seems to break up the markup surrounding the range, but even more
aggressively: even if it doesn't need to pull down styles.  In some cases this
does actually result in shorter markup, specifically if the existing tags are
short (like [[i]] or [[b]]) and we're adding tags that are long (like [[span]]
with a [[style]] attribute).
</div>

<ol>
  <li>If <var>node</var>'s [[parent]] is not an [[element]], abort this
  algorithm. <!-- E.g., a text node child of a document fragment. -->

  <li>If the <span>effective value</span> of <var>command</var> is <var>new
  value</var> on <var>node</var>, abort this algorithm.

  <li>Let <var>current ancestor</var> be <var>node</var>'s [[parent]].

  <li>Let <var>ancestor list</var> be a list of [[nodes]], initially empty.

  <li>While <var>current ancestor</var> is an <span>editable</span> [[element]]
  and the <span>effective value</span> of <var>command</var> is not <var>new
  value</var> on it, append <var>current ancestor</var> to <var>ancestor
  list</var>, then set <var>current ancestor</var> to its [[parent]].

  <li>If <var>ancestor list</var> is empty, abort this algorithm.

  <li>Let <var>propagated value</var> be the <span>specified value</span> of
  <var>command</var> on the last member of <var>ancestor list</var>.

  <!-- We can only remove specified values, so if the value isn't specified,
  give up.  Unless we're actually trying to push down a null specified value,
  like for unlink. -->
  <li>If <var>propagated value</var> is null and is not equal to <var>new
  value</var>, abort this algorithm.

  <!-- If we go all the way up to the root and still don't have the desired
  value, pushing down values is pointless.  It will create extra markup for no
  purpose.  Except if the value is null, which basically just means "try to get
  rid of anything affecting the current element but don't aim for any specific
  value". -->
  <li>If the <span>effective value</span> of <var>command</var> is not
  <var>new value</var> on the [[parent]] of the last member of <var>ancestor
  list</var>, and <var>new value</var> is not null, abort this algorithm.

  <li>While <var>ancestor list</var> is not empty:

  <ol>
    <li>Let <var>current ancestor</var> be the last member of <var>ancestor
    list</var>.

    <li>Remove the last member from <var>ancestor list</var>.

    <li>If the <span>specified value</span> of <var>current ancestor</var> for
    <var>command</var> is not null, set <var>propagated value</var> to that
    value.

    <li>Let <var>children</var> be the [[children]] of <var>current
    ancestor</var>.

    <li>If the <span>specified value</span> of <var>current ancestor</var> for
    <var>command</var> is not null, <span>clear the value</span> of
    <var>current ancestor</var>.

    <li>For every <var>child</var> in <var>children</var>:

    <ol>
      <li>If <var>child</var> is <var>node</var>, continue with the next
      <var>child</var>.

      <li>If <var>child</var> is an [[element]] whose <span>specified
      value</span> for <var>command</var> is neither null nor equal to
      <var>propagated value</var>, continue with the next <var>child</var>.

      <p class=XXX>This will be incorrect for relative font sizes.  If the font
      size on the parent was removed and the font size on the child is in ems
      or percents or something, it will now change value.  This isn't likely to
      come up, so we'll ignore it for now.

      <li>If <var>child</var> is the last member of <var>ancestor list</var>,
      continue with the next <var>child</var>.

      <li><span>Force the value</span> of <var>child</var>, with
      <var>command</var> as in this algorithm and <var>new value</var> equal
      to <var>propagated value</var>.
    </ol>
  </ol>
</ol>


<h2>Forcing the value of a node</h2>
<p>When a user agent is to <dfn>force the value</dfn> of a [[node]]
<var>node</var>, given a command <var>command</var> and a new value
<var>new value</var>, it must run the following steps.

<p class=note>This algorithm checks if the node has the desired value, and if
not, it wraps the node (or, if that's not possible, its descendants) in a
<span>simple modifiable element</span>.  This is only used as a last resort
after <span title="clear the value">clearing the value</span> and <span
title="push down values">pushing down values</span> don't work to achieve the
desired value.  After forcing the value, descendants might still have a
different value.

<ol>
  <li>If <var>node</var>'s [[parent]] is null, abort this algorithm.

  <li>If <var>new value</var> is null, abort this algorithm.

  <li>If <var>node</var> is an [[element]], [[text]], [[comment]], or
  [[processinginstruction]] node, and is not an <span>unwrappable
  node</span>:

  <ol>
    <!-- Even if the value matches, we stick it in a preceding sibling if
    possible.  This ensures "a<cite>b</cite>c" -> "<i>a<cite>b</cite>c</i>"
    instead of "<i>a</i><cite>b</cite><i>c</i>".  While we're at it, we also
    handle more elaborate cases like <b>foo</b>[bar]<b>baz</b> and even
    <i><b>foo</b></i>[bar]<i><b>baz</b></i> (the latter becomes
    <b><i>foo</i>bar<i>baz</i></b>).

    Theoretically this algorithm could pointlessly reorganize the DOM in the
    event of unreasonable style rules, but it's not a big enough deal for us to
    care, since the resulting style will still be right. -->
    <li>Let <var>candidate</var> be <var>node</var>'s [[previoussibling]].

    <li>While <var>candidate</var> is a <span>modifiable element</span>, and
    <var>candidate</var> has exactly one [[child]], and that [[child]] is also
    a <span>modifiable element</span>, and <var>candidate</var> is not a
    <span>simple modifiable element</span> or <var>candidate</var>'s
    <span>specified value</span> for <var>command</var> is not <var>new
    value</var>, set <var>candidate</var> to its [[child]].

    <li>If <var>candidate</var> is a <span>simple modifiable element</span>
    whose <span>specified value</span> and <span>effective value</span> for
    <var>command</var> are both <var>new value</var>, and <var>candidate</var>
    is not the [[previoussibling]] of <var>node</var>:

    <ol>
      <li>While <var>candidate</var> has [[children]], insert the first
      [[child]] of <var>candidate</var> into <var>candidate</var>'s [[parent]]
      immediately before <var>candidate</var>, <span>preserving ranges</span>.

      <li>Insert <var>candidate</var> into <var>node</var>'s [[parent]] before
      <var>node</var>'s [[previoussibling]].  <!-- If candidate had no
      children, any boundary point inside it will get moved to its parent here,
      which is okay.  We don't want to preserve ranges, because that would move
      boundary points that originally were in candidate but were moved to its
      parent by the last step to move to node's parent.  We move to before the
      previous sibling so that boundary points before and after the previous
      sibling wind up before or after candidate. -->

      <li>Append the [[nextsibling]] of <var>candidate</var> as the last
      [[child]] of <var>candidate</var>, <span>preserving ranges</span>.
    </ol>

    <li>Let <var>candidate</var> be <var>node</var>'s [[nextsibling]].

    <li>While <var>candidate</var> is a <span>modifiable element</span>, and
    <var>candidate</var> has exactly one [[child]], and that [[child]] is also
    a <span>modifiable element</span>, and <var>candidate</var> is not a
    <span>simple modifiable element</span> or <var>candidate</var>'s
    <span>specified value</span> for <var>command</var> is not <var>new
    value</var>, set <var>candidate</var> to its [[child]].

    <li>If <var>candidate</var> is a <span>simple modifiable element</span>
    whose <span>specified value</span> and <span>effective value</span> for
    <var>command</var> are both <var>new value</var>, and <var>candidate</var>
    is not the [[nextsibling]] of <var>node</var>:

    <ol>
      <li>While <var>candidate</var> has [[children]], insert the first
      [[child]] of <var>candidate</var> into <var>candidate</var>'s [[parent]]
      immediately before <var>candidate</var>, <span>preserving ranges</span>.

      <li>Insert <var>candidate</var> into <var>node</var>'s [[parent]] after
      <var>node</var>. <!-- Thus candidate is between the same boundary points
      as node's next sibling, not the same as node.  When inserting, the new
      thing always gets put in the same place as its next sibling, not its
      previous sibling: a boundary point at the place it's inserted moves
      before the new node, not after. -->

      <li>Append the [[nextsibling]] of <var>candidate</var> as the last
      [[child]] of <var>candidate</var>, <span>preserving ranges</span>.
    </ol>

    <li>Let <var>previous sibling</var> and <var>next sibling</var> be
    <var>node</var>'s [[previoussibling]] and [[nextsibling]].

    <li>If <var>previous sibling</var> is a <span>simple modifiable
    element</span> whose <span>specified value</span> and <span>effective
    value</span> for <var>command</var> are both <var>new value</var>, append
    <var>node</var> as the last [[child]] of <var>previous sibling</var>,
    <span>preserving ranges</span>.

    <li>If <var>next sibling</var> is a <span>simple modifiable element</span>
    whose <span>specified value</span> and <span>effective value</span> for
    <var>command</var> are both <var>new value</var>:

    <ol>
      <li>If <var>node</var> is not a [[child]] of <var>previous sibling</var>,
      insert <var>node</var> as the first [[child]] of <var>next sibling</var>,
      <span>preserving ranges</span>.

      <li>Otherwise, while <var>next sibling</var> has [[children]], append the
      first [[child]] of <var>next sibling</var> as the last [[child]] of
      <var>previous sibling</var>, <span>preserving ranges</span>.  Then remove
      <var>next sibling</var> from its [[parent]].
    </ol>
  </ol>

  <li>If the <span>effective value</span> of <var>command</var> is <var>new
  value</var> on <var>node</var>, abort this algorithm.

  <li>If <var>node</var> is an <span>unwrappable node</span>:

  <ol>
    <li>Let <var>children</var> be all [[children]] of <var>node</var>,
    omitting any that are [[element]]s whose <span>specified value</span> for
    <var>command</var> is neither null nor equal to <var>new value</var>.

    <li><span>Force the value</span> of each [[node]] in <var>children</var>,
    with <var>command</var> and <var>new value</var> as in this invocation of
    the algorithm.
    <!-- This means that if it has no children, we do nothing.  IE9 inserts an
    empty wrapper element in that case, but I'm not sure what the point is, and
    no one else does, so I don't.  WebKit seems to ignore the node if its only
    child consists solely of whitespace, but I don't see any grounds for that
    and no one else does, so I don't. -->

    <li>Abort this algorithm.
  </ol>

  <!-- At this point we have to make a new element as a wrapper.  This isn't
  worth the effort for comments or PIs, so abort in that case. -->
  <li>If <var>node</var> is a [[comment]] or [[processinginstruction]], abort
  this algorithm.

  <li>If the <span>effective value</span> of <var>command</var> is <var>new
  value</var> on <var>node</var>, abort this algorithm.

  <li>Let <var>new parent</var> be null.

  <li>If the <span>CSS styling flag</span> is false:

  <ol>
    <li>If <var>command</var> is "bold" and <var>new value</var> is
    "bold", let <var>new parent</var> be the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("b")</code> on the
    [[ownerdocument]] of <var>node</var>.

    <li>If <var>command</var> is "italic" and <var>new value</var> is
    "italic", let <var>new parent</var> be the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("i")</code> on the
    [[ownerdocument]] of <var>node</var>.

    <li>If <var>command</var> is "strikethrough" and <var>new value</var> is
    "line-through", let <var>new parent</var> be the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("s")</code> on the
    [[ownerdocument]] of <var>node</var>.

    <p class=XXX>Actual UAs use strike, not s, but s is shorter and HTML5 makes
    strike invalid.  I've gone with s for now, but maybe we want to change the
    spec to require strike.

    <li>If <var>command</var> is "underline" and <var>new value</var> is
    "underline", let <var>new parent</var> be the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("u")</code> on the
    [[ownerdocument]] of <var>node</var>.

    <li>If <var>command</var> is "foreColor", and <var>new value</var> is fully
    opaque with red, green, and blue components in the range 0 to 255:

    <ol>
      <li>Let <var>new parent</var> be the result of calling <code
      data-anolis-spec=domcore
      title=dom-Document-createElement>createElement("font")</code> on the
      [[ownerdocument]] of <var>node</var>.

      <li>If <var>new value</var> is one of the colors listed in the SVG color
      keywords section of CSS3 Color, set the [[fontcolor]] attribute of
      <var>new parent</var> to <var>new value</var>.

      <li>Otherwise, set the [[fontcolor]] attribute of <var>new parent</var>
      to the result of applying the <span data-anolis-spec=html>rules for
      serializing simple color values</span> to <var>new value</var>
      (interpreted as a <span data-anolis-spec=html>simple color</span>).
    </ol>

    <li>If <var>command</var> is "fontName", let <var>new parent</var> be
    the result of calling <code data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("font")</code> on the
    [[ownerdocument]] of <var>node</var>, then set the [[fontface]] attribute
    of <var>new parent</var> to <var>new value</var>.
  </ol>

  <li>If <var>command</var> is "createLink" or "unlink":

  <ol>
    <li>Let <var>new parent</var> be the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("a")</code> on the
    [[ownerdocument]] of <var>node</var>.

    <li>Set the [[href]] attribute of <var>new parent</var> to <var>new
    value</var>.

    <!-- Nested a elements are bad, because they can't be serialized to
    text/html.  hrefs should already have been cleared in a previous step, but
    we might have <a name> or such lurking about. -->
    <li>Let <var>ancestor</var> be <var>node</var>'s [[parent]].

    <li>While <var>ancestor</var> is not null:

    <ol>
      <li>If <var>ancestor</var> is an [[a]], <span>set the tag name</span> of
      <var>ancestor</var> to "span", and let <var>ancestor</var> be the
      result.

      <p class=XXX>This will mean any link-specific attributes will be
      transferred, which makes them both invalid and useless.  Is that okay?  I
      don't really want to list them all, because that sort of list is prone to
      bitrot.

      <li>Set <var>ancestor</var> to its [[parent]].
    </ol>
  </ol>

  <!-- WebKit is the only engine that ever outputs anything but font tags for
  fontSize.  For size=7, it uses font-size: -webkit-xxx-large.  We just output
  a font tag no matter what. -->
  <li>If <var>command</var> is "fontSize"; and <var>new value</var> is one of
  "xx-small", "small", "medium", "large", "x-large", "xx-large", or
  "xxx-large"; and either the <span>CSS styling flag</span> is false, or
  <var>new value</var> is "xxx-large": let <var>new parent</var> be the result
  of calling <code data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("font")</code> on the
  [[ownerdocument]] of <var>node</var>, then set the [[fontsize]] attribute of
  <var>new parent</var> to the number from the following table based on
  <var>new value</var>:

  <dl class=switch>
    <dt>xx-small <dd>1
    <dt>small <dd>2
    <dt>normal <dd>3
    <dt>large <dd>4
    <dt>x-large <dd>5
    <dt>xx-large <dd>6
    <dt>xxx-large <dd>7
  </dl>

  <!-- We always use sup/sub elements, even in CSS mode, following Gecko and
  contradicting WebKit.  This is because <span value="vertical-align:
  sub/super">, the obvious equivalent (and what WebKit uses), behaves quite
  differently: it doesn't reduce font-size, which is ugly. -->
  <li>If <var>command</var> is "subscript" or "superscript" and <var>new
  value</var> is "sub", let <var>new parent</var> be the result of calling
  <code data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("sub")</code> on the
  [[ownerdocument]] of <var>node</var>.

  <li>If <var>command</var> is "subscript" or "superscript" and <var>new
  value</var> is "super", let <var>new parent</var> be the result of calling
  <code data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("sup")</code> on the
  [[ownerdocument]] of <var>node</var>.

  <li>If <var>new parent</var> is null, let <var>new parent</var> be the result
  of calling <code data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("span")</code> on the
  [[ownerdocument]] of <var>node</var>.

  <li>Insert <var>new parent</var> in <var>node</var>'s [[parent]] before
  <var>node</var>.  <!-- This preserves boundary points correctly, as usual.
  -->

  <li>If the <span>effective value</span> of <var>command</var> for <var>new
  parent</var> is not <var>new value</var>, and the <span>relevant CSS
  property</span> for <var>command</var> is not null, set that CSS property of
  <var>new parent</var> to <var>new value</var> (if the new value would be
  valid).

  <li>If <var>command</var> is "strikethrough", and <var>new value</var> is
  "line-through", and the <span>effective value</span> of "strikethrough" for
  <var>new parent</var> is not "line-through", set the "text-decoration"
  property of <var>new parent</var> to "line-through".

  <li>If <var>command</var> is "underline", and <var>new value</var> is
  "underline", and the <span>effective value</span> of "underline" for <var>new
  parent</var> is not "underline", set the "text-decoration" property of
  <var>new parent</var> to "underline".

  <li>Append <var>node</var> to <var>new parent</var> as its last [[child]],
  <span>preserving ranges</span>.

  <li>If <var>node</var> is an [[element]] and the <span>effective value</span>
  of <var>command</var> for <var>node</var> is not <var>new value</var>:

  <ol>
    <li>Insert <var>node</var> into the [[parent]] of <var>new parent</var>
    before <var>new parent</var>, <span>preserving ranges</span>.

    <li>Remove <var>new parent</var> from its [[parent]].

    <li>If <var>new parent</var> is a [[span]], and either a)
    <var>command</var> is "underline" or "strikethrough", or b)
    <var>command</var> is "fontSize" and <var>new value</var> is not
    "xxx-large", or c) <var>command</var> is not "fontSize" and the
    <span>relevant CSS property</span> for <var>command</var> is not null:

    <ol>
      <li>If the <span>relevant CSS property</span> for <var>command</var> is
      not null, set that CSS property of <var>node</var> to <var>new
      value</var>.

      <li>If <var>command</var> is "strikethrough" and <var>new value</var> is
      "line-through", alter the "text-decoration" property of <var>node</var>
      to include "line-through" (preserving "overline" or "underline" if
      present).

      <li>If <var>command</var> is "underline" and <var>new value</var> is
      "underline", alter the "text-decoration" property of <var>node</var> to
      include "underline" (preserving "overline" or "line-through" if present).
    </ol>

    <li>Otherwise:

    <ol>
      <li>Let <var>children</var> be all [[children]] of <var>node</var>,
      omitting any that are [[element]]s whose <span>specified value</span> for
      <var>command</var> is neither null nor equal to <var>new value</var>.

      <li><span>Force the value</span> of each [[node]] in <var>children</var>,
      with <var>command</var> and <var>new value</var> as in this invocation
      of the algorithm.
    </ol>
  </ol>
</ol>


<h2>Setting the value of a node</h2>
<p>When a user agent is to <dfn>set the value</dfn> of a [[node]]
<var>node</var>, it must run the following steps.  There are two inputs: a
command <var>command</var> and a new value <var>new value</var>.

<div class=note>
<p>The effect of this algorithm is to ensure that the node and all its
descendants have the style requested, no matter what, producing the simplest
markup possible to achieve that effect.  It's inspired by the approach WebKit
takes.  The only places where the algorithm should fail are when there's an
!important CSS rule that conflicts with the requested style (which we don't try
to override because we assume it's !important for a reason), or when it's
literally impossible to succeed (such as when a text-decoration is propagated
from an ancestor we can't reach).  Any other failures are bugs.

<p>First, if the node is an element with an inline style rule for this
property, we unset it ("clearing styles").  This step also removes <span
title="simple modifiable element">simple modifiable elements</span> entirely, and
replaces elements like [[b]] or [[font]] with [[span]]s if they aren't simple
styling elements.  This will be sufficient if the desired style is inherited
from an ancestor, or if it's the default (like font-style: normal) and no
conflicting style is inherited from an ancestor.  Even if clearing styles
doesn't actually fix the style of the node we're dealing with, we do it anyway
to simplify the generated markup.

<p>If clearing styles didn't work, and it looks like an ancestor has inline
style that we're inheriting, we push the style down from that ancestor.  Thus
if we're unbolding the letter "r" in

<xmp><b>foo <i>bar</i> baz</b>,</xmp>

<p>we get

<xmp><b>foo </b><i><b>ba</b>r</i><b> baz</b>.</xmp>

<p>If we didn't push down styles, the final step (forcing styles) would instead
give us

<xmp><b>foo <i>ba<span style="font-weight: normal">r</span></i> baz</b>,</xmp>

<p>which is much longer and uglier.  We take care not to disturb the style or
semantics of anything but the node we're dealing with.

<p>We'll only push down styles if some ancestor actually has the style we want,
so we can inherit it.  Otherwise, it will just create useless markup.

<p>Finally, if neither of the above strategies worked, we have to add new
markup to get the desired style ("forcing styles").  First we try just sticking
it into its previous or next sibling, if that's a <span>simple modifiable
element</span> (so it won't add any styles or semantics we don't want).
Otherwise, we create a new simple styling element and wrap it in that.  It's
common that a previous sibling is the simple styling element we want, because
often we'll style several consecutive siblings in succession.  In that case,
the element created for the first can be reused for the later ones.

<p>This last step works a bit differently if the node is an <span>unwrappable
node</span>.  In that case, wrapping it in a simple styling element would
make the document less conforming than it already was.  Instead, we recursively
force style on its children.  The recursion will terminate when we hit a node
that's wrappable, or when there are no further descendants.

<p>After all this, the node is guaranteed to have the style we want, barring
bugs in the algorithm or the two exceptions noted earlier (!important style
rules, and impossible cases).  We then re-run the algorithm on each child
recursively.  Typically this means just clearing the style of each descendant,
because it should then inherit the style we just set on its ancestor.  In the
unusual case that a descendant's style is wrong even after we clear style on
it, such as because of a non-inline style rule (like trying to unbold a
heading), we'll repeat the above steps to ensure that the style really gets set
as desired.
</div>

<ol>
  <li>If <var>node</var> is a [[document]], <span>set the value</span> of its
  [[element]] [[child]] (if it has one) and abort this algorithm.

  <li>If <var>node</var> is a [[documentfragment]], let <var>children</var> be
  a list of its [[children]].  <span>Set the value</span> of each member of
  [[children]], then abort this algorithm.

  <li>If <var>node</var>'s [[parent]] is null, or if <var>node</var> is a <code
  data-anolis-spec=domcore>DocumentType</code>, abort this algorithm.

  <p class=XXX>We could style detached elements, but maybe it's not worth the
  effort.  Is execCommand() even supposed to work on things that don't descend
  from a document?  Needs investigation.

  <li>If <var>node</var> is not <span>editable</span>:
  <!--
  IE9: Allows everything to be modified by execCommand(), regardless of whether
    it's editable.
  Firefox 4.0: Ignores execCommand() if the start and end of the selection are
    not both editable.  If the start and end are editable but something in the
    middle is not, seems to relocate the non-editable part in the middle or
    something like that.
  Chrome 12 dev: Ignores execCommand() if the start and end of the selection
    are not both editable.  If the start and end are editable but something in
    the middle is not, applies the given command but skips the non-editable
    parts.  But the state doesn't ignore the non-editable parts, so if you bold
    such a selection you can't unbold it, for instance, since the middle part
    will remain bold (so it will keep on trying to bold it instead of switching
    to unbold).
  Opera 11.00: Ignores execCommand() if the start and end of the selection are
    not both editable.  If the start and end are editable but something in the
    middle is not, applies the command to everything, even the non-editable
    part.

  I chose to go with the non-IE behavior, per this discussion:
  http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2011-April/031147.html
  Ignoring non-editable things is convenient for the common use-case of an
  editor, where you don't want the user to bold random parts of the UI when
  they hit the bold button.  For cases where it's not desired, you can always
  turn designMode on briefly before using execCommand(), so the non-IE behavior
  is a lot easier to work around than the IE behavior.

  I don't see the value in ever just ignoring execCommand().  If the start and
  end are not editable, I'm going to say you should still style any editable
  nodes in between.  I'm also going to ignore non-editable nodes for the
  purposes of determining state, so (for instance) if all the editable nodes
  are bolded, it will unbold instead of bolding.
  -->

  <ol>
    <li>Let <var>children</var> be the [[children]] of <var>node</var>.

    <li><span>Set the value</span> of each member of <var>children</var>.

    <li>Abort this algorithm.
  </ol>

  <li>If <var>node</var> is an [[element]]:

  <ol>
    <li><span>Clear the value</span> of <var>node</var>, and let <var>new
    nodes</var> be the result.

    <li>For each <var>new node</var> in <var>new nodes</var>,
    <span>set the value</span> of <var>new node</var>.

    <li>If <var>node</var>'s [[parent]] is null, abort this algorithm.
  </ol>

  <li><span>Push down values</span> on <var>node</var>.

  <li><span>Force the value</span> of <var>node</var>.

  <li>Let <var>children</var> be the [[children]] of <var>node</var>.

  <li><span>Set the value</span> of each member of <var>children</var>.

  <p class=note>Styling a node involves clearing its styles, which can remove
  it from the tree.  Implementers should be careful to compute the list of
  children in full before they begin styling.
</ol>


<h2>Commands</h2>
<p>The <dfn title=execCommand()><code>execCommand(<var>commandId</var>,
<var>showUI</var>, <var>value</var>)</code></dfn> method on the
<code data-anolis-spec=html>HTMLDocument</code> interface allows scripts to
perform actions on the current selection or at the current caret position.
Generally, these commands would be used to implement editor UI, for example
having a "delete" button on a toolbar.

<p>There are three variants to this method, with one, two, and three arguments
respectively. The <var>showUI</var> and <var>value</var>
parameters, even if specified, are ignored except where otherwise stated.

<p>When <code>execCommand()</code> is invoked, the user agent must take the
action from the list below given by <var>commandId</var> on the first [[range]]
of the [[selection]] given by invoking [[getselection]] on the
[[contextobject]].  If no action is given in the list for <var>commandId</var>,
or if there is no [[range]] in that [[selection]], do nothing.

<p>The <dfn
title=queryCommandState()><code>queryCommandState(<var>commandId</var>)</code></dfn>
method on the <code data-anolis-spec=html>HTMLDocument</code> interface must
return the state of <var>commandId</var> on the first [[range]] of the
[[selection]] given by invoking [[getselection]] on the [[contextobject]], as
given by the list below.  If no state is given in the list for
<var>commandId</var>, or if there is no [[range]] in that [[selection]], return
false.
<!-- Gecko throws an exception if there are no ranges in the selection, but
other engines seem to just return false, which seems like nicer behavior
anyway.

Requesting the state of an unknown command throws an exception in IE 9 RC
and Firefox 4b11, and returns boolean false in Chrome 10 and Opera 11. -->

<p>The <dfn
title=queryCommandValue()><code>queryCommandValue(<var>commandId</var>)</code></dfn>
method on the <code data-anolis-spec=html>HTMLDocument</code> interface must
return the value of <var>commandId</var> on the first [[range]] of the
[[selection]] given by invoking [[getselection]] on the [[contextobject]], as
given by the list below.  If no value is given in the list for
<var>commandId</var>, or there is no [[range]] in that [[selection]], return
the empty string.
<!-- Requesting the value of an unknown command throws an exception in
IE 9 RC and in Firefox 4b11.  It returns boolean false in Chrome 10, and the
empty string in Opera 11. -->

<p class=XXX>Querying the value or state of an unrecognized command throws an
exception in IE and Firefox.  Need to consider changing to that behavior.

<p class=XXX>I say "first range" because I think that's what Gecko actually
does, and Gecko is the only one that allows multiple ranges in a selection.
This is keeping in mind that it stores ranges sorted by start, not by the order
the user added them, and silently removes or shortens existing ranges to avoid
overlap.  It probably makes the most sense in the long term to have the command
affect all ranges.  But I'll leave this for later.

<p>The possible values for <var>commandId</var>, and their corresponding
meanings, are as follows.  These values must be compared to the argument in an
<span data-anolis-spec=domcore>ASCII case-insensitive</span> manner.  The
<dfn>relevant CSS property</dfn> of a command is defined here, and is null if
omitted for a particular command.

<!--
Things that are only implemented by a couple of browsers and may or may not be
useful to spec:

* decreaseFontSize, increaseFontSize: Only implemented in Gecko and Opera.
* contentReadOnly, enableInlineTableEditing, enableObjectResizing, heading,
  insertBrOnReturn: MDC docs say not implemented in IE (didn't test).
* readOnly: MDC docs say it's a deprecated equivalent of contentReadOnly, so
  presumably like useCSS but less popular.
* 2D-Position, absolutePosition, clearAuthenticationCache, createBookmark,
  insertButton, insertFieldset, insertIframe, insertInput*, insertMarquee,
  insertSelectDropdown, insertSelectListbox, insertTextarea, liveResize,
  multipleSelection, overwrite, print, refresh, saveAs, unbookmark: Mentioned
  in MSDN docs but not MDC, so presumably IE-only.  Some of these seem
  inappropriate or useless, others will bear investigation.

Things I haven't looked at:

* copy, cut, paste: Needs attention to security.
* delete, redo, undo: Needs review of the Google work on this; will probably be
  quite complicated.
* formatBlock, insertOrderedList, insertUnorderedList, insertParagraph,
  justifyCenter, justifyFull, justifyLeft, justifyRight: These look important
  and should be similar to indent, so they're next on my list.
* insertHTML: Not supported by IE, but important.  I've seen frameworks that
  work around its absence in IE by using insertImage and then search and
  replace.  Will probably need to be defined in terms of insertAdjacentHTML or
  something.
* selectAll, unselect: Should be easy, although they seem redundant to just
  calling methods of the Selection.
-->

<dl>
<dt><code title><dfn title=command-backcolor>backColor</dfn></code>

<dd><strong>Action</strong>:

<div class=XXX>
<p>We have three behaviors to choose from for this one:

<ol>
  <li>Chrome 11 dev and IE 9 RC treat it the same as hiliteColor (although IE 9
  RC doesn't support hiliteColor itself).

  <li>Firefox 4 in non-CSS mode sets the bgcolor of the nearest td or body, or
  something like that.  In testing, it seems to jump out of contenteditable
  elements to style non-editable ancestors, which is alarming.

  <li>Firefox 4 in CSS mode and Opera 11 set the background of the nearest
  block container, although it doesn't seem to be very dependable (probably I
  just don't get what exactlyit's doing).
</ol>

<p>(1) is obviously redundant, but has plurality support, so we could spec it
that way if the other ways were useless.

<p>(3) is incoherent from a user perspective.  For instance, if you try it on
paragraphs the background will have big gaps where the margins are.  If you try
it on an inline element that's a child of the editing host, it will do nothing
or apply the background to everything or such, even though such an inline
element is visually indistinguishable from one sitting inside a div.  This
would only make sense if we take considerable effort to ensure that block
elements all have no margins, or if we wrap things in a div if they have
margins, or something like that.

<p>That leaves (2).  That might be useful if it actually set the document's
background color, but it seems like it sets table cell backgrounds sometimes
instead, which is really confusing.

<p>The path of least resistance seems to be to standardize this as meaning the
same thing as hiliteColor, and make up new commands if we want to do things
like set the document background color.  Feedback appreciated on this point.
</div>

<dd><strong>State</strong>:

<dd><strong>Value</strong>:


<dt><code title><dfn title=command-bold>bold</dfn></code>
<!-- If the selection is collapsed (but not if it contains nothing but is not
collapsed), IE9 wraps the whole line in a <strong>.  This seems bizarre and no
one else does it, so I don't do it.  It's a similar story for similar commands
(fontName, italic, etc.).  Except not for strikethrough, where it just does
nothing if the selection is empty.  Why strikethrough?  I don't know. -->

<dd><strong>Action</strong>: <span>Decompose</span> the [[range]].  If the
state of the [[range]] for this command is then true, <span>set the
value</span> of each returned [[node]] with <var>new value</var> "normal".
Otherwise, <span title="set the value">set their value</span> with <var>new
value</var> "bold".

<dd><strong>State</strong>: True if every <span>editable</span> [[text]] node
that is <span>effectively contained</span> in the [[range]] has <span>effective
value</span> at least 700.  Otherwise false.
<!-- For bold and similar commands, IE 9 RC seems to consider the state true or
false depending on the first element.  All other browsers follow the same
general idea as the spec, considering a range bold only if all text in it is
bold, and this seems to match at least OpenOffice.org's bold feature. -->

<dd><strong>Value</strong>: Always the empty string.
<!-- We have lots of options here (and presumably for all the others where
value is meaningless).  IE 9 RC returns the boolean false, Firefox 4b11 and
Opera 11 both return the empty string, Chrome 10 returns the string "false".
The HTML5 spec as of February 2011 mandates WebKit's behavior.  It makes sense
to always return a string, a majority of string-returners return the empty
string, and three out of the four return something that evaluates to false as a
boolean, so I'll go with Firefox and Opera. -->

<dd><strong>Relevant CSS Property</strong>: "font-weight"


<dt><code title><dfn title=command-createlink>createLink</dfn></code>

<dd><strong>Action</strong>: The user agent must run the following steps:
<!-- If the selection doesn't contain anything (meaning, e.g., deleteContents()
doesn't change anything), then Chrome 12 dev inserts a link at the selection
start, with the text equal to the link URL.  Other browsers don't do it, so I
don't either. -->

<ol>
  <li>If <var>value</var> is the empty string, abort these steps and do
  nothing.
  <!-- This matches Firefox 4b11 and Chrome 11 dev.  IE 9 RC and Opera 11 both
  treat the request literally.  Gecko and WebKit probably have it right here:
  users who enter no URL are very unlikely to want to link to a relative URL
  resolving to the current document.  If they really want to, they can always
  specify "#" for the value, or the author can rewrite it, so it's not like
  this makes the API less useful. -->

  <li><span>Decompose</span> the [[range]], and let <var>node list</var> be the
  result.

  <li>For each [[a]] element that has an [[href]] attribute and is an
  [[ancestor]] of some [[node]] in <var>node list</var>, set that element's
  [[href]] attribute to <var>value</var>.
  <!-- There are three approaches here.  For instance, if you ask browsers to
  create a link to "http://example.org" on the "b" here:

    <a href=http://example.com><b>Abc</b></a>

  Chrome 10 dev produces:

    <b><a href=http://example.com>A</a><a href=http://example.org>b</a>
    <a href=http://example.com>c</a></b>

  Firefox 4b11 produces (roughly):

    <a href=http://example.com><b>A<a href=http://example.org>b</a>c</b></a>

  (This doesn't round-trip through text/html serialization.)  IE 9 RC and Opera
  11 produce simply:

    <a href=http://example.org><b>Abc</b></a>

  The last behavior probably best matches user expectations.  If you happen to
  miss out a character when selecting the link you want to change, do you
  really intend to only change the link of part of it?
  -->

  <li><span>Set the value</span> of each [[node]] in <var>node list</var> to
  <var>value</var>.
</ol>

<dd><strong>State</strong>: Always false.

<dd><strong>Value</strong>: Always the empty string.
<!-- I'd have expected the value to be the URL, but guess not. -->


<dt><code title><dfn title=command-fontname>fontName</dfn></code>

<dd><strong>Action</strong>: <span>Decompose</span> the [[range]], then
<span>set the value</span> of each returned [[node]] with <var>new value</var>
equal to <var>value</var>.
<!-- UAs differ a bit in the details here:

IE 9 RC: Empty string sets <font face="">
Firefox 4b11: Empty string does nothing
Chrome 11 dev: Empty string does nothing, '"monospace"' same as 'monospace'
  (i.e., cannot escape font-family keywords because quotes are stripped,
  clearly wrong)
Opera 11: Empty string sets <font face="">

Setting an empty font-family has the effect of inheriting the font from the
parent (although I don't see where the February 24, 2011 CSS 3 Fonts draft says
that).  Thus it makes sense that if we special-case this, it should be to unset
the font somehow.

Special-casing the empty string to do nothing doesn't make sense to me.  With
createLink we'd expect the user to enter the URL themselves, so it makes sense
to special-case clicking OK without entering anything.  But here it's very
likely that the font list will be fixed by the author (how many users will
understand CSS font-family syntax?), so I don't think such usability concerns
apply. -->

<dd><strong>State</strong>: Always false.

<dd><strong>Value</strong>: The computed value of the CSS property
"font-family" for . . .
<!-- Complicated.

IE 9 RC: Always the empty string.  Not very useful.
Firefox 4b11: Confusing.  Sometimes it returns generic family names, like
  "sans-serif".  Sometimes it gives specific font names, like "tt" when the
  font is specified as "monospace".  Sometimes it gives the literal font-family
  string.  Not sure what it's doing here.
Chrome 11 dev: Gives the literal value of font-family, except if it's inherited
  from default values (no explicit style declarations anywhere), when it seems
  to return the exact font name.
Opera 11: Returns the literal value of font-family, except if it's inherited
  from default values, when it returns the empty string.

I'm just going to punt on this and say it should be the computed value of
font-family.  I'll leave CSSOM to decide what that means if there are no
applicable style rules. -->

<dd><strong>Relevant CSS Property</strong>: "font-family"


<dt><code title><dfn title=command-fontsize>fontSize</dfn></code>

<dd><strong>Action</strong>:
<!--
IE 9: Parses the value as a number (allowing floating-point), rounds to the
  nearest integer, then clamps to the range 1 to 7.  If the value is not a
  valid number, including if it has trailing characters (like "2em"), does
  nothing.  Normalizes relative sizes, so "+0" is the same as "+3", etc.
  Treats empty string the same as "1".
Firefox 4.0: Passes the value through literally to <font size=>, so "2em" gets
  you <font size="2em">.  Always uses <font>, even with styleWithCss true.
  Ignores the command if the value is the empty string.
Chrome 12 dev: Parses the value as a legacy font size, so "2em" becomes "2",
  then outputs a <font> with the resulting number.  If there is no resulting
  number, like for a value of "xx-small", does nothing.  In styleWithCss mode,
  outputs a span with corresponding CSS keywords: 1 = x-small, 2 = small,
  . . ., 6 = xx-large, 7 = -webkit-xxx-large.  Normalizes relative sizes, so
  "+0" is the same as "3", etc.  Ignores the command if the value is the empty
  string.
Opera 11: Parses the value as an integer (ignoring floating-point as trailing
  characters), then outputs that.  This means that "+0" becomes <font size=0>
  instead of <font size=+0> or <font size=3>.  Non-numeric values get
  interpreted as 0.  Does not clamp, and is willing to output negative numbers.
  Treats empty string as "0".

What all of these have in common is that they force the author to deal with
legacy font values and don't let them use CSS.  This is undesirable, so I
ignore how implementations behave.  Practically any value that did the same
thing in IE and Firefox should still do the same thing here, so I'm only
respecifying non-interoperable behavior anyway.
-->
<ol>
  <li>If <var>value</var> is the empty string, do nothing and abort these
  steps.

  <li><span data-anolis-spec=html>Strip leading and trailing whitespace</span>
  from <var>value</var>.

  <li>If <var>value</var> is a <span data-anolis-spec=html>valid floating point
  number</span>, or would be a <span data-anolis-spec=html>valid floating point
  number</span> if a single leading "+" character were stripped:

  <ol>
    <li>If the first character of <var>value</var> is "+", delete the character
    and let <var>mode</var> be "relative-plus".

    <li>Otherwise, if the first character of <var>value</var> is "-", delete
    the character and let <var>mode</var> be "relative-minus".

    <li>Otherwise, let <var>mode</var> be "absolute".

    <li>Apply the <span data-anolis-spec=html>rules for parsing non-negative
    integers</span> to <var>value</var>, and let <var>number</var> be the
    result.

    <li>If <var>mode</var> is "relative-plus", add three to <var>number</var>.

    <li>If <var>mode</var> is "relative-minus", negate <var>number</var>, then
    add three to it.

    <li>If <var>number</var> is less than one, let <var>number</var> equal 1.

    <li>If <var>number</var> is greater than seven, let <var>number</var> equal
    7.

    <li>Set <var>value</var> to the string here corresponding to
    <var>number</var>:

    <dl class=switch>
      <dt>1 <dd>xx-small
      <dt>2 <dd>small
      <dt>3 <dd>medium
      <dt>4 <dd>large
      <dt>5 <dd>x-large
      <dt>6 <dd>xx-large
      <dt>7 <dd>xxx-large
    </dl>

    <p class=XXX>The entry for 7 here is an issue: there's no CSS value that
    corresponds to it.  Even if we got one added to the drafts, it wouldn't be
    backward-compatible to use it.  WebKit is the only engine that supports CSS
    output for fontSize, and it uses -webkit-xxx-large in this case, which is
    unworkable.  Instead, we just always output a font tag for size 7.  If
    authors want conforming markup, they'll need to give CSS sizes above size
    7, not legacy sizes.
  </ol>

  <li>If <var>value</var> is not one of the strings "xx-small", "x-small",
  "small", "medium", "large", "x-large", "xx-large", "xxx-large", and is not a
  valid CSS absolute length, then do nothing and abort these steps.

  <p class=XXX>Not sure this is the best way to do it.  We don't want to allow
  relative lengths, because those can have very weird user-visible behavior.
  For instance, a size of 2em would sometimes double the text size, but if you
  applied it a second time it would do nothing, but if you deselected one
  character it would suddenly double the size again.  Current UAs just only
  allow numeric values.  There's no harm in allowing "x-small" and absolute
  sizes, I don't think.

  <li><span>Decompose</span> the [[range]], then <span>set the value</span> of
  each returned [[node]] to <var>value</var>.
</ol>

<dd><strong>State</strong>:

<dd><strong>Value</strong>:

<dd><strong>Relevant CSS Property</strong>: "font-size"


<dt><code title><dfn title=command-forecolor>foreColor</dfn></code>

<dd><strong>Action</strong>:
<!-- Color interpretations (wide screen recommended):

                        IE9           Firefox 4.0              Chrome 12 dev            Opera 11.00
red                     red           red                      #ff0000                  #ff0000
f                       #f            -                        -                        #f00000
#f                      #f            -                        -                        #f00000
f00                     #f00          -                        #ff0000                  #0f0000
#f00                    #f00          rgb(255, 0, 0)           #ff0000                  #0f0000
ff0000                  #ff0000       -                        #ff0000                  #ff0000
#ff0000                 #ff0000       rgb(255, 0, 0)           #ff0000                  #ff0000
fff000000               #ff0000       -                        -                        #fff000
#fff000000              #ff0000       -                        -                        #fff000
rgb(255, 0, 0)          rgb(255,0,0)  rgb(255, 0, 0)           #ff0000                  #00b025
rgb(100%, 0, 0)         rgb(255,0,0)  -                        -                        #00b010
rgb( 255 ,0 ,0)         rgb(255,0,0)  rgb(255, 0, 0)           #ff0000                  #00b025
rgba(255, 0, 0, 0.0)    #005000       rgba(255, 0, 0, 0)       rgba(255, 0, 0, 0.0)     #00ba02
rgb(375, -10, 15)       rgb(255,0,15) rgb(255, 0, 15)          #ff000f                  #00b037
rgba(0, 0, 0, 1)        #ba0010       rgb(0, 0, 0)             -                        #00ba00
rgba(255, 255, 255, 1)  #000055       rgb(255, 255, 255)       #ffffff                  #00ba02
rgba(255, 0, 0, 0.5)    #005000       rgba(255, 255, 255, 0.5) rgba(255, 0, 0, 0.49804) #00ba02
hsl(0%, 100%, 50%)      #001050       -                        -                        -
cornsilk                cornsilk      cornsilk                 #fff8dc                  #fff8dc
potato quiche           #0000c0       -                        -                        #000a00
transparent             transparent   -                        rgba(0, 0, 0.0)          #00a000
currentColor            #c0e000       currentcolor             rgba(0, 0, 0.0)          #c000e0

The interpretations given for Firefox are only in styleWithCSS mode.  In
non-styleWithCSS mode, it just outputs the string literally as the <font color>
attribute value, which can lead to different results.  The given output for
Chrome is for <font>; the output in styleWithCSS mode is the same, but rgb() is
used instead of hex notation, and "transparent" and "currentcolor" are passed
through under those names.  IE and Opera only support <font> to begin with.

Conclusions:

* Everyone accepts simple color keywords and #xxxxxx notation.
* Opera mangles #xxx, but everyone else handles it fine.
* The leading # is optional in all browsers but Gecko.
* rgb() is accepted by everyone but Opera.
* rgba() is accepted by Gecko and WebKit, but rejected by IE and Opera.
* hsl() isn't accepted by anyone.
* IE and Opera mangle unrecognized stuff, Gecko and WebKit ignore.
* Browsers will happily output stuff like "transparent" and "rgba()" into <font
  color> even though it won't be uniformly accepted there.
* Opera and WebKit normalize the output color very aggressively, Gecko leaves
  keywords intact but otherwise normalizes for CSS output (but doesn't
  normalize at all for <font>), and IE normalizes inconsistently.

What I'm going to say is that it either has to be a valid CSS color, or
prefixing it with # must result in a valid CSS color.  For <font>, I'll say
that the output color should be normalized to #xxxxxx form unless it's an SVG
color keyword, in which case it's passed through intact.  If the color is not a
simple color (fully opaque with all channels between 0 and 255), I'll force
style="" even if styleWithCSS mode is off.  Some of this disagrees with all
browsers, but it's unlikely to hurt and it makes sense.
-->
<ol>
  <li>If <var>value</var> is not a valid CSS color, prepend "#" to it.

  <li>If <var>value</var> is still not a valid CSS color, or if it is
  currentColor, do nothing and abort these steps.
  <!-- currentColor is bad for the same reason as relative font sizes.  It will
  confuse the algorithm, and doesn't seem very useful anyway. -->

  <li><span>Decompose</span> the [[range]], then <span>set the value</span> of
  each returned [[node]] to <var>value</var>.
</ol>

<dd><strong>State</strong>: Always false.
<!-- This matches IE 9 RC and Chrome 10.  Opera 11 seems to return true if
there's some color style applied, false otherwise, which seems fairly useless;
authors want to use value here, not state.  Firefox 4b11 throws an exception,
which is an interesting approach, but I'll go with IE/WebKit, which makes at
least as much sense. -->

<dd><strong>Value</strong>:
<!-- IE 9 RC returns the number 0 always, which makes no sense at all. -->

<dd><strong>Relevant CSS Property</strong>: "color"


<dt><code title><dfn title=command-hiliteColor>hiliteColor</dfn></code>
<!-- IE 9 RC doesn't support this.  It uses backColor instead, but Gecko and
Opera treat that differently, while all non-IE browsers treat hiliteColor the
same, so I'm standardizing hiliteColor as the way to highlight text.

This is slightly tricky, because background-color does different things on
block and inline elements.  Given the name ("hiliteColor"), we really only want
to apply it to inline elements.  This is how everyone but Gecko behaves, but
Gecko sometimes applies it to blocks too.  WebKit doesn't set it on non-inline
elements, but does clear it and push it down from them.

The spec doesn't do any of these: background-color on non-inline elements is
not touched by hiliteColor, neither created nor removed.  If users want to
remove the style, they need to use removeFormat.  Adding it usually makes no
sense; see the comment for backColor.

For color parsing, see the comment for foreColor. -->

<dd><strong>Action</strong>:

<ol>
  <li>If <var>value</var> is not a valid CSS color, prepend "#" to it.

  <li>If <var>value</var> is still not a valid CSS color, or if it is
  currentColor, do nothing and abort these steps.
  <!-- currentColor is bad for the same reason as relative font sizes.  It will
  confuse the algorithm, and doesn't seem very useful anyway.  For hiliteColor
  you could conceive of it being useful, but it will still confuse the
  algorithm, so ban it for now anyway. -->

  <li><span>Decompose</span> the [[range]], then <span>set the value</span> of
  each returned [[node]] to <var>value</var>.
</ol>

<dd><strong>State</strong>: Always false.

<dd><strong>Value</strong>:

<dd><strong>Relevant CSS Property</strong>: "background-color"


<dt><code title><dfn title=command-indent>indent</dfn></code>
<!--
IE9: Outputs <blockquote style="margin-right: 0px" dir="ltr">, or when
  surrounding RTL blocks, <blockquote style="margin-left: 0px" dir="rtl">.  The
  direction seems to go by the end of the selection.  The presence of the dir
  attribute means that any contents that were inheriting a different dir from
  an ancestor get their direction changed as a side effect, but if they
  actually have the opposite dir specified, they won't appear to be indented.
  It doesn't reset top or bottom margins on the blockquote, so it adds them.
  If it's not wrapping a block element, like if it's only wrapping up until a
  <br>, it adds a <p>.
Firefox 4.0: In styleWithCSS mode, adds style="margin-left: 40px" to the
  appropriate block container (or margin-right if it's RTL).  If there's no
  appropriate block container, adds a div.  If multiple blocks are affected, it
  goes by the direction of the block whose style it's changing, which winds up
  being wrong for descendants with different direction.  In non-styleWithCSS
  mode, uses <blockquote>, so it indents on both sides and also adds top/bottom
  margins.
Chrome 12 dev: Outputs <blockquote class="webkit-indent-blockquote"
  style="margin: 0 0 0 40px; border: none; padding: 0px"> in both modes for
  both LTR and RTL (which is broken for RTL, since it indents only on the
  left).
Opera 11.00: Outputs <blockquote>, so it indents on both sides and on the
  top/bottom.

For repeated indentation, everyone except Opera that outputs <blockquote>s just
puts them at the outermost possible location, which works well.  Opera puts
them in the innermost position, which is broken, because it will even put them
inside <p> (which will not round-trip through text/html serialization).

Gecko in CSS mode messes up by adding margins even to things like <blockquote>
that already have margins from CSS rules, instead of nesting a div, so it
doesn't actually increase the indentation.  However, if an element has an
explicit left margin (assuming LTR), it will increase the margin to 80px, so it
works with WebKit's blockquotes.


We have two strategies for handling directionality: always indent on both sides
(Firefox non-CSS, Opera) or try to figure out heuristically which side we want
(IE, Firefox CSS).  The latter approach is only possible by adding extra markup
and complexity, so for now we'll take the easy way out and go with just
indenting on both sides.


This reasoning doesn't discuss lists.  For research on lists, see the comment
for insertOrderedList.  List handling is more complicated and I wound up
differing from all browsers in lots of ways.
-->

<dd><strong>Action</strong>:

<p class=XXX>Handle corner cases: endpoints are detached, documents, document
fragments, html/body, head or things in head . . .

<ol>
  <li>Let <var>items</var> be a list of all [[li]]s that are
  [[ancestorcontainers]] of the [[range]]'s [[rangestart]] and/or [[rangeend]]
  [[bpnode]].

  <li>For each <var>item</var> in <var>items</var>, <span>normalize
  sublists</span> of <var>item</var>.
  <!-- This overnormalizes, but it seems like the simplest solution for now.
  -->

  <li><span>Block-extend</span> the [[range]], and let <var>new range</var> be
  the result.

  <li>Let <var>node list</var> be a list of [[nodes]], initially empty.

  <li>For each [[node]] <var>node</var> [[contained]] in <var>new range</var>,
  if <var>node</var> is <span>editable</span> and can be the [[child]] of a
  [[div]] or [[ol]] or [[ul]] and if no [[ancestor]] of <var>node</var> is in
  <var>node list</var>, append <var>node</var> to <var>node list</var>.

  <li>If the first member of <var>node list</var> is an [[li]] whose [[parent]]
  is an [[ol]] or [[ul]], and its [[previoussibling]] is an [[li]] as well,
  <span>normalize sublists</span> of its [[previoussibling]].
  <!-- Otherwise the last child of the previous sibling might be a list, which
  the li wouldn't get appended to. -->

  <li>While <var>node list</var> is not empty:

  <ol>
    <li>Let <var>sublist</var> be a list of [[nodes]], initially empty.

    <li>Remove the first member of <var>node list</var> and append it to
    <var>sublist</var>.

    <li>While the first member of <var>node list</var> is the [[nextsibling]]
    of the last member of <var>sublist</var>, remove the first member of
    <var>node list</var> and append it to <var>sublist</var>.

    <li><span>Indent</span> <var>sublist</var>.
  </ol>
</ol>

<!--
We have to handle entire lists of siblings at once, or else we'd wind up doing
something like

  <ol>
    {<li>foo</li>
    <ol><li>bar</li></ol>}
  </ol>
  ->
  <ol><ol>
    <li>foo</li>
    <li>bar</li>
  </ol></ol>
  ->
  <ol><ol><ol>
    <li>foo</li>
    <li>bar</li>
  </ol></ol></ol>

since by the time we got to doing the <ol> that originally contained "bar", we
won't remember that we aren't supposed to indent "foo" a second time.
-->
<p>To <dfn>indent</dfn> a list <var>node list</var> of consecutive [[sibling]]
[[nodes]]:

<ol>
  <li>If <var>node list</var> is empty, do nothing and abort these steps.

  <li>Let <var>first node</var> be the first member of <var>node list</var>.

  <li>If <var>first node</var>'s [[parent]] is an [[ol]] or [[ul]]:

  <ol>
    <li>Let <var>tag</var> be the [[localname]] of the [[parent]] of
    <var>first node</var>.

    <li><span>Wrap</span> <var>node list</var>, with <span>sibling
    criteria</span> matching only <span title="HTML element">HTML
    elements</span> with [[localname]] <var>tag</var> and <span>new parent
    instructions</span> returning the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement(<var>tag</var>)</code> on
    the [[ownerdocument]] of <var>first node</var>.
    <!--
    This matches IE9, Firefox 4.0, and Chrome 12 dev.  If there's a preceding
    <li>, Opera 11.10 instead adds the new parent to the end of that <li>, so
    it's not the child of another list, which is invalid.  But the other
    browsers' way of doing things makes things simpler.  E.g., if we want to
    indent an <li> and it has <ol>/<ul> children, we have to distinguish
    between the case where we want to indent the whole <li> or only the first
    part.  It also allows things like

      <ol><li>
        foo
        <ol><li>bar</li></ol>
        baz
      </li></ol>

    in which case it's unclear what we should do if the user selects "foo" and
    indents.  I've filed a bug on HTML5:

    http://www.w3.org/Bugs/Public/show_bug.cgi?id=12609
    -->

    <li>Abort these steps.
  </ol>

  <li>Let <var>tag</var> be "div" if the <span>CSS styling flag</span> is
  true, otherwise "blockquote".
  <!-- Firefox 4.0 is the only tested browser that respects the CSS styling
  flag for indent at all.  For indent, as for inline markup commands like
  bold, it will modify the inline style of existing elements if available,
  and only create spans/divs if there are no existing elements where it could
  add the style instead.  For indent as for other commands, I follow WebKit
  and always create an extra element, to ensure consistency between CSS and
  non-CSS modes. -->

  <li><span>Wrap</span> <var>node list</var>.  <span>Sibling criteria</span>
  must match only an <span>indentation element</span> whose "display" property
  computes to "block" and whose "margin-left" and "margin-right" properties
  compute to "40px", and whose "margin-top" and "margin-bottom" properties
  compute to "0".  The <span>new parent instructions</span> are to call <code
  data-anolis-spec=domcore
  title=dom-Document-createElement>createElement(<var>tag</var>)</code> on the
  [[ownerdocument]] of <var>first node</var>, then set the CSS property
  "margin" of the returned node to "0 40px", then return the returned node.

  <p class=XXX>This indents on both sides, so we don't have to worry about
  directionality.  Preferably we should indent only on the start side, but
  that requires care to get right in mixed-direction cases.  Even once
  browsers start to support margin-start and so on, we can't use them because
  a) we have to work okay in legacy browsers and b) it doesn't help if a
  descendant block has different direction (so should be indented the other
  way).

  <p class=XXX>IE9 doesn't handle an explicit margin attribute very well when
  outdenting: it propagates it to the parent when removing the element, which
  doesn't actually remove the indentation.  So indentation per spec (or
  Gecko in CSS mode or WebKit) will not be removed correctly by IE.  I'm
  leaving the style in because this short-term incompatibility is preferable
  to the long-term incorrectness of adding top/bottom margins or adding
  margins on both sides.  I can't think of any better way to do this at the
  moment.
</ol>

<dd><strong>State</strong>:

<dd><strong>Value</strong>:


<dt><code title><dfn title=command-inserthorizontalrule>insertHorizontalRule</dfn></code>

<dd><strong>Action</strong>:
<!-- You'd think interop here would be simple, right?  Nope: we have three
different behaviors across four browsers.  Opera 11.00 is the only one that
acts more or less like the spec.  IE9 and Chrome 12 dev treat the value as an
id, which is weird and probably useless, so I don't do it.  Firefox 4.0
produces <hr size=2 width=100%> instead of <hr>, which is also weird and almost
definitely useless, so I don't do it.  Then you have the varying behavior in
splitting up parents to ensure validity . . . -->

<ol>
  <li>Run <code data-anolis-spec=domrange
  title=dom-Range-deleteContents>deleteContents()</code> on the [[range]].

  <li>Let <var>hr</var> be the result of calling <code
  data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("hr")</code> on the
  [[contextobject]].

  <li>Run <code data-anolis-spec=domrange
  title=dom-Range-insertNode>insertNode(<var>hr</var>)</code> on the [[range]].
  <!-- This might put it in an inline element, where it's invalid.  This is
  what IE9 and Chrome 12 dev appear to do.  Firefox 4.0 breaks up inline
  ancestors, and Opera 11.10 seems to put it before the first inline ancestor
  instead of where the cursor is.  Breaking up elements is kind of evil, so
  I'll go with IE/WebKit.  Even though it produces invalid markup, it does
  still work. -->

  <li>Run <code data-anolis-spec=domrange
  title=dom-Selection-collapse>collapse()</code> on the [[selection]], with
  first argument equal to the [[parent]] of <var>hr</var> and the second
  argument equal to one plus the [[index]] of <var>hr</var>.
</ol>

<dd><strong>State</strong>:

<dd><strong>Value</strong>:


<dt><code title><dfn title=command-insertimage>insertImage</dfn></code>

<dd><strong>Action</strong>:

<ol>
  <li>If <var>value</var> is the empty string, abort these steps and do
  nothing.
  <!-- Similar logic to createLink, except even more compelling, since an HTML
  document linking to itself as an image is just silly.  In fact, the current
  HTML spec instructs UAs to not even try displaying the image, and just fail
  immediately if the URL is empty.  Firefox 4b11 bails out on an empty string,
  but the other three browsers I tested stick in the <img> anyway. -->

  <li>Run <code data-anolis-spec=domrange
  title=dom-Range-deleteContents>deleteContents()</code> on the [[range]].

  <li>Let <var>img</var> be the result of calling <code
  data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("img")</code> on the
  [[contextobject]].

  <li>Run <code data-anolis-spec=domcore
  title=dom-Element-setAttribute>setAttribute("src", <var>value</var>)</code>
  on <var>img</var>.
  <!-- No alt text, so it's invalid.  This matches all browsers. -->

  <li>Run <code data-anolis-spec=domrange
  title=dom-Range-insertNode>insertNode(<var>img</var>)</code> on the
  [[range]].

  <li>Run <code data-anolis-spec=domrange
  title=dom-Selection-collapse>collapse()</code> on the [[selection]], with
  first argument equal to the [[parent]] of <var>img</var> and the second
  argument equal to one plus the [[index]] of <var>img</var>.
</ol>

<dd><strong>State</strong>:

<dd><strong>Value</strong>:


<!--
Research for insertOrderedList/insertUnorderedList: tested the following
command sequences in IE9, Firefox 4.0, Chrome 12 dev, Opera 11.10,
OpenOffice.org 3.2.1 Ubuntu package, Microsoft Office Word 2007.  The commands
"ol", "ul", "indent", "outdent" correspond in browsers to "insertOrderedList",
"insertUnorderedList", "indent", and "outdent"; in OO.org to "Numbering
On/Off", "Bullets On/Off", "Increase Indent", "Decrease Indent"; and in Word to
"Numbering", "Bullets", "Increase Indent", "Decrease Indent".

Note: OO has a bunch of extra options, like "Promote One Level", "Demote One
Level", "Promote One Level With Subpoints", "Demote One Level With Subpoints",
"Insert Unnumbered Entry", "Restart Numbering".  The regular "Increase/Decrease
Indent" commands work oddly, and I assume they're not really meant to be used
inside lists.  Thus I also tested with "Promote One Level" and "Demote One
Level".  These are denoted by OO' instead of OO.

Assume that there are style rules in effect like

ol ol { list-style-type: lower-alpha }
ol ol ol { list-style-type: lower-roman }

This is the default appearance in Word, and I set OO to something similar with
Bullets and Numbering -> Outline in the list editing toolbox.  I'm ignoring
bullet style throughout, for no particular reason.

* In an existing ordered list equivalent to <ol><li>foo<li>bar<li>baz</ol>quz:
  * Select "bar", do "ol":
    * Word/OO: Remove indent and number "2", change "3" to "2".
    * Browsers: Remove indent and number "2", change "3" to "1".
    * Spec: Same as browsers.
  * Select "bar", do "ul":
    * Word: Leave indent the same, change "2" to a bullet, change "3" to "2".
    * OO: Increase indent, change "2" to a bullet, change "3" to "2".
    * IE: Change all numbers to bullets.
    * Firefox/Chrome/Opera: Leave indent the same, change "2" to a bullet, change "3" to "1".
    * Spec: Same as Firefox/Chrome/Opera.
  * Select "bar", do "indent":
    * Word/OO'/Browsers: Increase indent, change "2" to "a", change "3" to "2".
    * OO: Increase indent, do not change any numbers.
    * Spec: Same as Word/OO'/Browsers.
  * Select "bar", do "outdent":
    * Word: Do nothing.
    * OO: Leave indent the same, de-indent "2" so it goes past the left margin (?!), do not change any numbers.
    * OO': Option grayed out.
    * Browsers: Remove indent and the number "2", change "3" to "1".
    * Spec: Same as browsers.
  * Select "quz", do "ol":
    * Word/OO/IE/Chrome: Add as fourth item to existing list, numbered "4".
    * Firefox/Opera: Create new list, number the item "1".
    * Spec: Same as OO/Word/IE/Chrome.
* In an existing ordered list equivalent to <ol><li>foo<br>bar<li>baz</ol>:
  * Select "foo", do "ol":
    * Word/OO/IE/Chrome/Opera: Remove indent from both "foo" and "bar", change "2" -> "1".
    * Firefox: Increase indent for "foo" only, add additional "a" marker after "1" and before "foo".
    * Spec: Same as Word/OO/IE/Chrome/Opera.
  * Select "foo", do "ul":
    * Word/Opera: Change "1" -> bullet, "2" -> "1".
    * OO: Increase indent for both "foo" and "bar", change "1" -> bullet, "2" -> "1".
    * IE: Change all numbers to bullets.
    * Firefox: Increase indent for "foo" only, add additional bullet marker after "1" and before "foo".
    * Chrome: Remove indent from "bar", change "1" -> bullet, "2" -> "1".
    * Spec: Same as Word/Opera.
  * Select "foo", do "indent":
    * Word: Increase indent for whole list.
    * OO: Increase indent for both "foo" and "bar".
    * OO': Increase indent for "foo", change "1" -> "a".
    * IE/Firefox non-CSS/Opera: Increase indent for both "foo" and "bar", change "1" -> "a", "2" -> "1".
    * Firefox CSS: Increase indent for "foo" only (<div style="margin-left: 40px">).
    * Chrome: Increase indent for "foo" only, add "a" before "foo", move "1" to be before "bar".
    * Spec: Same as IE/Firefox non-CSS/Opera.
  * Select "foo", do "outdent":
    * Word: Decrease indent for whole list, so it goes past the left margin.
    * OO: Decrease indent for "bar" and "1." (so "1." goes past the left margin), but not "foo".
    * OO': Option grayed out.
    * IE/Chrome/Opera: Remove indent from both "foo" and "bar", remove "1", change "2" -> "1".
    * Firefox: Do nothing.
    * Spec: Same as IE/Chrome/Opera.
  * Select "bar", do "ol":
    * Word/OO/IE/Chrome/Opera: Remove indent from both "foo" and "bar", change "2" -> "1".
    * Firefox: Increase indent for "bar" only, add "a" marker before it.
    * Spec: Same as Word/OO/IE/Chrome/Opera.
  * Select "bar", do "ul":
    * Word/Opera: Change "1" -> bullet, "2" -> "1".
    * OO: Increase indent for both "foo" and "bar", change "1" -> bullet, "2" -> "1".
    * IE: Change all numbers to bullets.
    * Firefox: Increase indent for "bar" only, add bullet marker before it.
    * Chrome: Remove indent from "foo", change "1" -> bullet and move it before "bar", change "2" -> "1".
    * Spec: Same as Word/Opera.
  * Select "bar", do "indent":
    * Word: Increase indent for whole list.
    * OO: Increase indent for both "foo" and "bar".
    * OO': Increase indent for "foo", change "1" -> "a".
    * IE/Firefox non-CSS/Opera: Increase indent for both "foo" and "bar", change "1" -> "a", "2" -> "1".
    * Firefox CSS: Increase indent for "bar" only (<div style="margin-left: 40px">).
    * Chrome: Increase indent for "bar" only, add "a" before "bar", move "bar" above "foo" (?!).
    * Spec: Same as IE/Firefox non-CSS/Opera.
  * Select "bar", do "outdent":
    * Word: Decrease indent for whole list, so it goes past the left margin.
    * OO: Decrease indent for "bar" and "1." (so "1." goes past the left margin), but not "foo".
    * OO': Option grayed out.
    * IE/Chrome/Opera: Remove indent from both "foo" and "bar", remove "1", change "2" -> "1".
    * Firefox: Do nothing.
    * Spec: Same as IE/Chrome/Opera.
* In an existing nested ordered list equivalent to <ol><li>foo<ol><li>bar<li>baz</ol><li>quz</ol>:
  * Select "bar", do "ol":
    * Word/IE/Firefox: Decrease indent, remove "a" ("bar" is aligned with "foo" with no marker of its own), change "b" -> "a".
    * OO: Remove all indent, change "b" -> "a".
    * Chrome: Decrease indent, change "a" -> "2", "b" -> "a", "2" -> "3".
    * Opera: Decrease indent, change "a" -> "2", "b" -> "a", "2" -> "4", insert extra "3" list marker before new "a".
    * Spec: Same as Chrome.
  * Select "bar", do "ul":
    * Word/Firefox/Chrome: Change "a" -> bullet, "b" -> "a".
    * OO: Increase indent, change "a" -> bullet, "b" -> "a".
    * IE: Change "a" and "b" to bullets.
    * Opera: Change "a" -> bullet, "b" -> "a", "2" -> "4", insert extra list markers "2" and "3" before new bullet and "a".
    * Spec: Same as Word/Firefox/Chrome.
  * Select "bar", do "indent":
    * Word/OO'/IE: Increase indent, change "a" -> "i", leave "b" alone.
    * OO: Increase indent, do not change numbers.
    * Firefox/Chrome/Opera: Increase indent, change "a" -> "i", "b" -> "a".
    * Spec: Same as Firefox/Chrome/Opera.
  * Select "bar", do "outdent":
    * Word/OO'/IE/Chrome: Decrease indent, change "a" -> "2", "b" -> "a", "2" -> "3".
    * OO: Leave indent the same, de-indent "a" so it goes past the left margin (?!).
    * Firefox: Decrease indent, remove "a" ("bar" is aligned with "foo" with no marker of its own), change "b" -> "a".
    * Opera: Decrease indent, change "a" -> "2", "b" -> "a", "2" -> "4", insert extra list marker "3" before new "a".
    * Spec: Same as Word/OO'/IE/Chrome.
* In existing nested lists equivalent to <ol><li>foo<ul><li>bar<li>baz</ul><li>quz</ol>:
  * Select "bar", do "ol":
    * Word: Change all bullets to numbers.  (Not letters, even though indented!)
    * OO: Decrease indent, change first bullet -> "2", "2" -> "3".
    * IE: Change all bullets to letters.
    * Firefox/Chrome: Change first bullet to "a".
    * Opera: Change first bullet -> "a", "2" -> "4", insert extra list markers "2" and "3" before new "a" and bullet.
    * Spec: Same as Firefox/Chrome.
  * Select "bar", do "ul":
    * Word/IE/Firefox: Decrease indent, remove first bullet ("bar" is aligned with "foo" with no marker of its own).
    * OO: Remove all indent, remove first bullet, leave all else the same.
    * Chrome: Decrease indent, change first bullet -> "2", "2" -> "3".
    * Opera: Decrease indent, change first bullet -> "2", "2" -> "4", insert extra list marker "3" before old bullet.
    * Spec: Same as Chrome.
  * Select "bar", do "indent":
    * Word: Increase indent, change first bullet to "i" (?!).
    * OO/OO'/Firefox/Chrome/Opera: Increase indent.
    * IE: Increase indent, change "2" -> "3" (?!?!).  (I don't see from the markup why the 2 actually changes to a 3.  The markup seems to be as other browsers.)
    * Spec: Same as OO/OO'/Firefox/Chrome/Opera.
  * Select "bar", do "outdent":
    * Word/IE/Chrome: Decrease indent, change first bullet -> "2", "2" -> "3".
    * OO: Usual crazy stuff, move bullet left but leave text alone.
    * OO': Option grayed out.  (Interesting.)
    * Firefox: Decrease indent, remove first bullet ("bar" is aligned with "foo" with no marker of its own).
    * Opera: Decrease indent, change first bullet -> "2", "2" -> "4", insert extra list marker "3" before old bullet.
    * Spec: Same as Word/IE/Chrome.
* In an existing nested ordered list equivalent to <ol><li>foo<li>bar<ol><li>baz</ol><li>quz</ol>:
  * Select "bar", do "ol":
    * Word/OO: Remove indent and "2", change "3" -> "2".
    * IE/Chrome/Opera: Remove indent and "2", decrease indent of "baz", change "2" and "3" -> "1".
    * Firefox: Increase indent, add extra "a" marker between "2" and "bar".
    * Spec: Different from all of them: remove indent and "2", change "3" -> "1".
  * Select "bar", do "ul":
    * Word: Change "2" -> bullet.
    * OO: Increase indent, change "2" -> bullet, "3" -> "2".
    * IE: Change "1", "2", "3" -> bullets (and "a" to "1").
    * Firefox: Increase indent, add extra bullet marker between "2" and "bar".
    * Chrome: Decrease indent of "baz", change "2" -> bullet, "a" and "3" -> "1".
    * Opera: Change "2" -> bullet, "a" and "3" -> "1".
    * Spec: Different from all of them: change "2" -> bullet, "3" -> "1".
  * Select "bar", do "indent":
    * Word/OO': Increase indent, change "2" -> "a", "a" -> "b", "3" -> "2".
    * OO: Increase indent (double amount, past "baz").
    * Firefox non-CSS/Opera: Increase indent of both "bar" and "baz", change "2" -> "a", "a" -> "i", "3" -> "2".
    * Firefox CSS: Increase indent.
    * Chrome: Increase indent, add "a" marker before "bar", move "2" marker to before the "a" marker of "baz".
    * Spec: Same as Word/OO'.
  * Select "bar", do "outdent":
    * Word/Firefox: Do nothing.
    * OO: Decrease indent on "2", leave "bar" alone.
    * OO': Option grayed out.
    * IE: Decrease indent of "baz", change "2" and "3" -> "1", "a" -> "2".
    * Chrome/Opera: Decrease indent of "bar" and "baz", remove "2", change "a" and "3" -> "1".
    * Spec: Different from all of them: remove indent and "2", change "3" -> "1".
* In an existing nested ordered list equivalent to <ol><li>foo<li>bar<ol><li>baz</ol>quz<li>qoz</ol>:
  * Does not appear to be possible in Word or OO.
  * Also might be impossible to actually make such a list using execCommand() in browsers.
  * Suffice it to say that there's a lot of variation.
* In an existing indented region equivalent to foo<blockquote>bar</blockquote>baz:
  * Select "bar", do "ol":
    * Word/OO/Firefox/Chrome: Increase indent, add "1".
    * IE: Increase indent, add "a".
    * Opera: Add "1" (but do not increase indent).
  * Select "foobar", do "ol":
    * Word/IE: Increase indent of both, add "1" before "foo" and "a" before
      "bar".
    * OO: Increase indent of "bar" one step, increase indent of "foo" two steps
      so it's aligned with "bar", add "1" before "foo" and "2" before "bar".
    * Firefox: Increase indent of both, add "1" before foo", add "2" before
      "bar" aligned with the "1" of "foo" (so large gap between "2" and "bar").
    * Chrome: Increase indent of "foo", add "1" before "foo" and "2" before
      "bar".
    * Opera: Mash everything together on one line.  But if you do
      <p>foo</p><blockquote>bar</blockquote><p>baz</p> instead, same as Chrome.
  * Select "foo" and do "ol", then select "bar" and do "ol":
    * Word/OO/Firefox/Opera: Different than doing both at once (often in
      exciting ways).
    * IE/Chrome: Same as doing both at once.
* <p>foo</p><blockquote><p>bar</p><p>baz</p></blockquote>
  * Select "foobar" and do "ol":
    * Word: One-item list with sublist.
    * OO/Firefox/Chrome/Opera: One two-item list, unindented.
    * IE9: Two one-item lists.
  * Select "foo", do "ol", then select "bar" and do "ol":
    * Word/OO/Chrome: One two-item list, unindented.
    * IE9/Firefox: Two one-item lists.
    * Opera: Two one-item lists, both unindented.
  * Desired behavior: One-item list with sublist in both cases.
* In an existing multi-line indented region equivalent to <blockquote>foo<br>bar<br>baz</blockquote>:
  * Select "bar", do "ol":
    * Word/OO/Firefox/Chrome: Increase indent, add "1".
    * IE: Increase indent of everything, add "a" before "foo".  If you do
      <blockquote><p>foo<p>bar<p>baz</blockquote>, same as
      Word/OO/Firefox/Chrome.
    * Opera: Don't increase indent of anything, add "1" before "bar".
* In an existing multi-line indented region equivalent to <blockquote>foo<br>bar</blockquote>baz:
  * Select "barbaz", do "ol":
    * Word: Indent both, add "a" before "bar" and "2" before "baz".
    * OO: Indent "baz", add "1" before "bar" and "2" before "baz".
    * IE: Indent everything, add "a" before "foo" and "1" before "baz".  If you
      do <blockquote><p>foo<p>bar</blockquote><p>baz, indent "bar" and "baz"
      and put "1" before each.
    * Firefox: Indent "bar" and put "1" before it, put "baz" after "bar" on the
      same line.  If you do <blockquote><p>foo<p>bar</blockquote><p>baz, same
      as Chrome.
    * Chrome: Indent "bar" once and "baz" twice, put "1" before "bar" and "2"
      before "baz".
    * Opera: Put a "1" before "bar" and move "baz" to the same line.  If you do
      <blockquote><p>foo<p>bar</blockquote><p>baz, indent "baz", put a "1"
      before "bar" and a "2" before "baz".
  * Select "bar", do "ol", then select "baz" and do "ol":
    * Word/OO/Opera: Different from if you do both together.
    * IE: Different with <br>, same with <p>.
    * Firefox: Three behaviors, depending on whether you do it in one step with
      <br>, one step with <p>, or two steps with either (same behavior
      regardless with two steps).
    * Chrome: Same behavior in all four cases.
* <blockquote>foo<ol><li>bar</ol></blockquote>baz:
  * Select "baz", do "ol":
    * Word/OO/Chrome: Add "baz" as a new item to existing list.
    * IE/Firefox/Opera: Make "baz" its own new list.
* <ul><li>foo</li><ol><li>bar</li></ol></ul>baz:
  * Select "baz", do "ol":
    * IE/Firefox/Chrome/Opera: Separate list.

Ignoring the conceptual model of HTML, which users won't understand, here's the
conceptual model I've developed for lists: text is divided up into blocks.
Each block has an indentation level and a list marker type.  The list marker
type can be either nothing, ordered, or unordered.  A list block cannot have
indentation level less than one.  Any given piece of text is part of only one
block.  A block may be visually non-contiguous, such as if a single list block
is interrupted by a further-indented block.

To find the right number (or letter) for an ordered-list block, look at the
immediately preceding block, but skip over any blocks of higher indentation
level.  If there is no immediately preceding block, or it's not an ordered-list
block, or it has a lower indentation level, the number is 1 (or a, i, etc.).
Otherwise, it's the number of the preceding block plus one.

ol/ul commands change the selected block to that list marker type, or remove
the list marker type if it's already the chosen type.  If the block has
indentation level zero, it increases to one.

indent/outdent commands change the selected block's indentation level.  If a
list block's indentation level is reduced to zero, it's converted to a regular
block.

What this means from an HTML perspective, roughly:

* A list block is the entire contents of an <li> element, ignoring any nested
  list elements or indentation elements.  A non-list block is a line box.
* Indentation level is equal to the number of ancestor elements that are either
  <li>s or indentation elements (blockquotes or indenting divs).
* To find the list marker type, go to the first ancestor that's either an <li>
  or indentation element.
* Correct numbering should automatically follow from the way <ol> works in HTML
  (which is one of the reasons I use this model).
* An ol command in an ordered-list block removes the surrounding <li>,
  migrating its contents into the parent of the <ol>.  This splits up the <ol> if
  it's not the first or last child, and wraps the contents in a new <li> if
  necessary.  If there's another list or indentation element nested in the <li>
  we're removing, it will get re-wrapped in a new <ol>, outside the
  newly-created <li>, so that it maintains its indentation.  This might cause
  the new <li> to wind up in multiple pieces, if the original block was not
  contiguous, which means the non-contiguous block is split into several blocks
  (with different numbers).
* An ol command in an unordered-list block breaks up the parent <ul> and puts a
  new <ol> in between the two pieces, moving the parent <li> into it.  If the
  <li> was the first or last child, we merge with an existing adjacent <ol> if
  possible.  All children stay as they are.
* An ol command in a non-list block with indentation zero wraps it in a new
  <ol><li>, or merges with an adjacent <ol> if possible.
* An ol command in a non-list block with nonzero indentation converts the
  parent to an <ol><li>, breaking it up if necessary.
* The ul command works similarly to ol.
* indent in a non-list block wraps in an indentation element.  In a list block,
  it wraps the <li> in an extra <ol> or <ul> as appropriate.  With merging.
  Whatever.  Let me just write the spec.
* outdent in a non-list block strips an indentation element, if one is present.
  In a list block, it breaks apart the parent <ol> or <ul> and makes the
  affected block a sibling in between the newly-split list elements.  Will
  create new <li>s, etc. etc.

Sheesh, lists are complicated.
-->
<dt><code title><dfn title=command-insertorderedlist>insertOrderedList</dfn></code>

<dd><strong>Action</strong>:

<ol>
  <li>Let <var>items</var> be a list of all [[li]]s that are
  [[ancestorcontainers]] of the [[range]]'s [[rangestart]] and/or [[rangeend]]
  [[bpnode]].

  <li>For each <var>item</var> in <var>items</var>, <span>normalize
  sublists</span> of <var>item</var>.
  <!-- This overnormalizes, but it seems like the simplest solution for now.
  -->

  <li><span>Block-extend</span> the [[range]], and let <var>new range</var> be
  the result.

  <li>Let <var>node list</var> be a list of [[nodes]], initially empty.

  <li>For each [[node]] <var>node</var> [[contained]] in <var>new range</var>,
  if <var>node</var> is <span>editable</span>; the last member of <var>node
  list</var> (if any) is not an [[ancestor]] of <var>node</var>;
  <var>node</var> is not a <span>potential indentation element</span>; and
  either <var>node</var> is an [[ol]] or [[ul]], or its [[parent]] is an [[ol]]
  or [[ul]], or it can be the [[child]] of an [[li]]; then append
  <var>node</var> to <var>node list</var>.
  <!--
  We exclude potential indentation elements so that selecting some random text
  and doing indent followed by insertOrderedList will have the same result as
  the reverse.  Specifically,

    <blockquote>[foo]</blockquote> ->
    <blockquote><ol><li>[foo]</li></ol></blockquote>

  per spec and Firefox 4.0 and (more or less) Chrome 12 dev.  Opera 11.10
  instead does <ol><li>foo</li></ol>, so the indentation vanishes.  IE9 does
  <ol><ol><li>foo</li></ol></ol>, but that doesn't make semantic sense and is
  different from how it would work if you reversed the commands.
  OpenOffice.org 3.2.1 (Ubuntu) and Word 2007 both agree with the spec in this
  case.

  We don't ask whether the node's parent can contain an <ol>.  The only place
  where this is likely to cause serious problems is <p>, which we special-case.
  -->

  <p class=XXX>Similar to a number of other places in the spec, "can be the
  child" is not well-defined, and it's not clear what the right definition
  should be.

  <li>While <var>node list</var> is not empty:

  <ol>
    <li>Let <var>sublist</var> be an empty list of [[nodes]].

    <li>Remove the first member of <var>node list</var> and append it to
    <var>sublist</var>.

    <li>If the first member of <var>sublist</var> is an [[ol]],
    <span>outdent</span> it.

    <li>Otherwise, if the first member of <var>sublist</var> is a [[ul]],
    <span>set the tag name</span> of the first member of <var>sublist</var> to
    "ol".

    <li>Otherwise, if the [[parent]] of the first member of <var>sublist</var>
    is an <span>editable</span> [[ol]]:
    <!-- Outdent -->

    <ol>
      <li>While <var>node list</var> is not empty, and the first member of
      <var>node list</var> is the [[nextsibling]] of the last member of
      <var>sublist</var>, and the first member of <var>node list</var> is not
      an [[ol]] or [[ul]], remove the first member from <var>node list</var>
      and append it to <var>sublist</var>.

      <li><span>Split the parent</span> of <var>sublist</var>.

      <li><span>Fix orphaned list items</span> in <var>sublist</var>.
    </ol>

    <li>Otherwise, if the [[parent]] of the first member of <var>sublist</var>
    is an <span>editable</span> [[ul]]:
    <!-- Split up the parent -->

    <ol>
      <li>While <var>node list</var> is not empty, and the first member of
      <var>node list</var> is the [[nextsibling]] of the last member of
      <var>sublist</var>, and the first member of <var>node list</var> is not
      an [[ol]] or [[ul]], remove the first member from <var>node list</var>
      and append it to <var>sublist</var>.

      <li><span>Split the parent</span> of <var>sublist</var>.

      <li><span>Wrap</span> <var>sublist</var>, with <span>sibling
      criteria</span> matching any [[ol]], and with <span>new parent
      instructions</span> returning the result of calling <code
      data-anolis-spec=domcore
      title=dom-Document-createElement>createElement("ol")</code> on the
      [[contextobject]].
    </ol>

    <li>Otherwise:
    <!-- General case.  Add an ol wrapper for each line.  <br> breaks apart
    <li>'s, and multiple consecutive <br>s or trailing <br>s become empty
    <li>s. -->

    <ol>
      <li>If the first member of <var>sublist</var> is a [[p]] or [[li]] or
      [[div]], <span>set the tag name</span> of the first member of
      <var>sublist</var> to "li", and let <var>li</var> be the result.  Remove
      the first member of <var>sublist</var>, and append <var>li</var> to
      <var>sublist</var>.

      <li>Otherwise:

      <ol>
        <li>While <var>node list</var> is not empty, and the first member of
        <var>node list</var> is the [[nextsibling]] of the last member of
        <var>sublist</var>, and the last member of <var>sublist</var> and first
        member of <var>node list</var> are both <span title="inline
        node">inline nodes</span>, and the last member of <var>sublist</var> is
        not a [[br]], remove the first member from <var>node list</var> and
        append it to <var>sublist</var>.

        <li>Let <var>li</var> be the result of calling <code
        data-anolis-spec=domcore
        title=dom-Document-createElement>createElement("li")</code> on the
        [[ownerdocument]] of the first member of <var>sublist</var>.
      </ol>

      <li>If the [[nextsibling]] of the last member of <var>sublist</var> is an
      [[ol]]:

      <ol>
        <li>Insert <var>li</var> as the first [[child]] of the [[nextsibling]]
        of the last member of <var>sublist</var>, <span>preserving
        ranges</span>.

        <li>If the first member of <var>sublist</var> is an [[li]], remove it
        from <var>sublist</var>.

        <li>For each <var>node</var> in <var>sublist</var> <em>in reverse
        order</em>, insert <var>node</var> as the first [[child]] of
        <var>li</var>, <span>preserving ranges</span>.
      </ol>

      <li>Otherwise:

      <ol>
        <li>Let <var>ol</var> be the [[previoussibling]] of the first member of
        <var>sublist</var>.

        <li>Let <var>original parent</var> be the [[parent]] of the first
        member of <var>sublist</var>.

        <li>If <var>ol</var> is null, and <var>original parent</var> is an
        <span>editable</span> <span>indentation element</span>, and the
        [[previoussibling]] of <var>original parent</var> is an
        <span>editable</span> [[ol]]:

        <ol>
          <li>Let <var>ol</var> be the [[previoussibling]] of <var>original
          parent</var>.

          <li><span>Normalize sublists</span> of <var>ol</var>'s last [[child]].

          <li>If <var>ol</var>'s last [[child]] is not an <span>editable</span>
          [[ol]], call <code data-anolis-spec=domcore
          title=dom-Document-createElement>createElement("ol")</code> on the
          [[ownerdocument]] of <var>ol</var>, and append the result as the last
          [[child]] of <var>ol</var>.

          <li>Set <var>ol</var> to its last [[child]].
        </ol>

        <li>If <var>ol</var> is not an <span>editable</span> [[ol]]:

        <ol>
          <li>If <var>original parent</var> is a [[p]], <span>split the
          parent</span> of <var>sublist</var>, and then set <var>original
          parent</var> to the [[parent]] of the first member of
          <var>sublist</var>.

          <li>Let <var>ol</var> be the result of calling <code
          data-anolis-spec=domcore
          title=dom-Document-createElement>createElement("ol")</code> on the
          [[ownerdocument]] of the first member of <var>sublist</var>.

          <li>Insert <var>ol</var> into <var>original parent</var> immediately
          before the first member of <var>sublist</var>.
        </ol>

        <li>Append <var>li</var> as the last [[child]] of <var>ol</var>,
        <span>preserving ranges</span>.

        <li>If the first member of <var>sublist</var> is an [[li]], remove it
        from <var>sublist</var>.

        <li>For each <var>node</var> in <var>sublist</var>, append
        <var>node</var> as the last [[child]] of <var>li</var>,
        <span>preserving ranges</span>.

        <li>If <var>original parent</var> has no [[children]], remove it from
        its [[parent]].
        <!-- This might happen if it's an indentation element whose previous
        sibling is an ol, for instance. -->
      </ol>
    </ol>

    <li><span>Remove extraneous line breaks</span> from <var>ol</var>.

    <li><span>Remove extraneous line breaks</span> from <var>li</var>.
  </ol>
</ol>


<dt><code title><dfn title=command-italic>italic</dfn></code>

<dd><strong>Action</strong>: <span>Decompose</span> the [[range]].  If the
state of the [[range]] for this command is then true, <span>set the
value</span> of each returned [[node]] with <var>new value</var> "normal".
Otherwise, <span title="set the value">set their value</span> with <var>new
value</var> "italic".

<dd><strong>State</strong>: True if every <span>editable</span> [[text]] node
that is <span>effectively contained</span> in the [[range]] has <span>effective
value</span> either "italic" or "oblique".  Otherwise false.

<dd><strong>Value</strong>: Always the empty string.

<dd><strong>Relevant CSS Property</strong>: "font-style"


<dt><code title><dfn title=command-outdent>outdent</dfn></code>

<dd><strong>Action</strong>:

<ol>
  <li>Let <var>items</var> be a list of all [[li]]s that are
  [[ancestorcontainers]] of the [[range]]'s [[rangestart]] and/or [[rangeend]]
  [[bpnode]].

  <li>For each <var>item</var> in <var>items</var>, <span>normalize
  sublists</span> of <var>item</var>.
  <!-- This overnormalizes, but it seems like the simplest solution for now.
  -->

  <li><span>Block-extend</span> the [[range]], and let <var>new range</var> be
  the result.

  <li>Let <var>node list</var> be a list of [[nodes]], initially empty.

  <li>For each [[node]] <var>node</var> [[contained]] in <var>new range</var>:

  <ol>
    <li>If the last member of <var>node list</var> (if any) is an [[ancestor]]
    of <var>node</var>, or if <var>node</var> is not <span>editable</span>,
    continue with the next <var>node</var>.

    <!--
    This step is kind of weird.  For regular outdenting, we start at the inside
    and outdent going out, so that we remove the innermost indentation, on the
    theory that that will produce the cleanest markup (remove the most nodes).
    For lists, we remove the outermost indentation, because it makes a
    difference whether we remove inner or outer indentation, and logically we
    want to remove outer.  E.g.,

      <ol><li>foo</li><ul><li>bar</li></ul></ol>

    should become

      foo<ul><li>bar</li></ul>

    not

      foo<ol><li>bar</li></ol>.

    But this is a bit weird and I'm wondering if it's really correct.
    -->
    <li>If <var>node</var> has no <span>editable</span> [[descendants]], or is
    an [[ol]] or [[ul]], or is an [[li]] whose [[parent]] is an [[ol]] or
    [[ul]], append it to <var>node list</var>.
  </ol>

  <li>While <var>node list</var> is not empty:

  <ol>
    <li>While the first member of <var>node list</var> is an [[ol]] or [[ul]]
    or is not the [[child]] of an [[ol]] or [[ul]], <span>outdent</span> it and
    remove it from <var>node list</var>.

    <li>If <var>node list</var> is empty, break from these substeps.

    <li>Let <var>sublist</var> be a list of [[nodes]], initially empty.

    <li>Remove the first member of <var>node list</var> and append it to
    <var>sublist</var>.

    <li>While the first member of <var>node list</var> is the [[nextsibling]]
    of the last member of <var>sublist</var>, and the first member of <var>node
    list</var> is not an [[ol]] or [[ul]], remove the first member of <var>node
    list</var> and append it to <var>sublist</var>.

    <li><span>Split the parent</span> of <var>sublist</var>.

    <li><span>Fix orphaned list items</span> in <var>sublist</var>.
  </ol>
</ol>

<p>To <dfn>outdent</dfn> a [[node]] <var>node</var>:

<!--
Things that are produced for indentation that we need to consider removing:

* Plain <blockquote> (produced by Opera 11.00 and non-CSS Firefox 4.0)
* <blockquote style="margin-right: 0" dir="ltr"> and <blockquote
  style="margin-left: 0" dir="rtl"> (IE9)
* <blockquote class="webkit-indent-blockquote" style="margin: 0 0 0 40px;
  border: none; padding: 0px"> (Chrome 12 dev)
* <div style="margin-left: 40px"> and <div style="margin-right: 40px">
  (CSS Firefox 4.0 if no other element available)
* <blockquote style="margin: 0 40px"> and <div style="margin: 0 40px"> (spec)
* Other random things with display: block whose left or right margin was
  increased by 40px (CSS Firefox 4.0)

For discussion on the list-related stuff, see the comment for
insertOrderedList.
-->
<ol>
  <li>If <var>node</var> is not <span>editable</span>, abort these steps.

  <!-- The easy case is when the whole element is indented.  In this case we
  remove the whole thing indiscriminately.  In the case of blockquotes
  created by IE, this might change the direction of some children, but then
  their direction was probably changed incorrectly in the first place, so no
  harm. -->
  <li>If <var>node</var> is an <span>indentation element</span>, remove
  <var>node</var>, <span>preserving its descendants</span>.  Then abort these
  steps.

  <!-- No browser handles the case of Firefox 4.0 in CSS mode, where it adds a
  margin attribute to an existing element, including Firefox itself.  So let's
  just skip it. -->

  <li>If <var>node</var> is a <span>potential indentation element</span>:
  <!-- This might be an indentation element that had style added to it by
  Firefox in CSS mode, for instance (color, font-family, etc.). -->

  <ol>
    <li>Unset the <code data-anolis-spec=html title=classes>class</code> and
    <code data-anolis-spec=html title="the dir attribute">dir</code>
    attributes of <var>node</var>, if any.

    <li>Unset the margin, padding, and border CSS properties of
    <var>node</var>.

    <li><span>Set the tag name</span> of <var>node</var> to "div".

    <li>Abort these steps.
  </ol>

  <!-- Approximate algorithms when an ancestor is causing the indentation
  appear to be:

  IE9: Go to the innermost element causing indentation.  If the stuff to be
    outdented includes all the contents of that element, get rid of it, but
    if it has any attributes, change it to a <p> with those same attributes.
    This is an excellent idea in general, but unfortunately it preserves
    explicitly-specified margins in style attributes, which isn't great.  In
    other cases, it moves the stuff to be outdented outside.  Not clear on
    all the details, seems to be pretty confusing.  Also does a bunch of
    seemingly arbitrary normalization like removing divs and some attributes
    from some things . . .
  Firefox 4.0: Go to the innermost element causing indentation.  If the stuff
    to be outdented includes all the contents of that element, get rid of it,
    even if it has arbitrary attributes.  Otherwise, move the stuff to be
    outdented outside the indenting element.  If there are any intervening
    elements that include stuff not to be outdented, wrap the outdented stuff
    in copies (which can duplicate id's, etc.).
  Chrome 12 dev: Go to the outermost element causing indentation (even if the
    current element is itself causing indentation).  Move the text to be
    outdented outside that outermost element, without regard to any
    intervening elements.  Then recreate the original styles on the moved
    text, in some fashion.  Something like that; it confuses me and doesn't
    seem to be reasonable.
  Opera 11.00: Like Firefox, except it goes to the outermost element, not the
    innermost.  Also seems to special-case to avoid duplicate id's, and has a
    few other quirks.

  Overall, all flawed, so I'll make up my own, patterned after pushing down
  styles.  First we search ancestors for an indentation element, which we stand
  a chance of completely removing.  Failing that, we look for a potential
  indentation element, which we cannot completely remove. -->
  <li>Let <var>current ancestor</var> be <var>node</var>'s [[parent]].

  <li>Let <var>ancestor list</var> be a list of [[nodes]], initially empty.

  <li>While <var>current ancestor</var> is an <span>editable</span> [[element]]
  that is not an <span>indentation element</span>, append <var>current
  ancestor</var> to <var>ancestor list</var> and then set <var>current
  ancestor</var> to its [[parent]].

  <li>If <var>current ancestor</var> is not an <span>editable</span>
  <span>indentation element</span>:

  <ol>
    <li>Let <var>current ancestor</var> be <var>node</var>'s [[parent]].

    <li>Let <var>ancestor list</var> be the empty list.

    <li>While <var>current ancestor</var> is an <span>editable</span>
    [[element]] that is not a <span>potential indentation element</span>,
    append <var>current ancestor</var> to <var>ancestor list</var> and then set
    <var>current ancestor</var> to its [[parent]].
  </ol>

  <li>If <var>current ancestor</var> is not an <span>editable</span>
  <span>potential indentation element</span>, and <var>node</var> is an [[ol]]
  or [[ul]]:
  <!-- This matches IE9 and Firefox 4.0.  When asked to outdent a list wrapped
  in an indentation element, Chrome 12 dev removes the list instead of the
  indentation element.  Opera 11.10 seems to remove both. -->

  <div class=XXX>
  <p>We don't handle a case like

  <xmp><ol><ol style="color: red"><li>foo<li>bar</ol><li>baz</ol></xmp>

  <p>If the inner [[ol]] is selected to be outdented, "foo" and "bar" will stop
  being red.  It seems nontrivial to handle this case in general, since we
  can't group [[li]]s.  If the list we're outdenting is a child of a non-list,
  then we can just change it to a div.
  </div>
  <!--
  Chrome 12 dev seems to special-case style attributes by converting them to
  the corresponding inline markup elements (at least in easy cases like color).
  For other attributes and non-WebKit browsers (IE9/FF4/O11.10), it looks like
  all the attributes are just removed.  Maybe we should try to copy WebKit
  here.
  -->

  <ol>
    <li>Unset the <code data-anolis-spec=html
    title=attr-ol-reversed>reversed</code>, <code data-anolis-spec=html
    title=attr-ol-start>start</code>, and <code data-anolis-spec=html
    title=attr-ol-type>type</code> attributes of <var>node</var>, if any are
    set.

    <li>Let <var>children</var> be the [[children]] of <var>node</var>.

    <li>If <var>node</var> has attributes, and its [[parent]] or not an [[ol]]
    or [[ul]], <span>set the tag name</span> of <var>node</var> to "div".

    <li>Otherwise remove <var>node</var>, <span>preserving its descendants</span>.

    <li><span>Fix orphaned list items</span> in <var>children</var>.

    <li>Abort these steps.
  </ol>

  <li>If <var>current ancestor</var> is not an <span>editable</span>
  <span>potential indentation element</span>, abort these steps.

  <!-- At this point, we have an ancestor to split up. -->
  <li>Append <var>current ancestor</var> to <var>ancestor list</var>.

  <li>Let <var>original ancestor</var> be <var>current ancestor</var>.
  <!-- We can't outdent it yet, because we need its children to remain intact
  for the loop. -->

  <li>While <var>ancestor list</var> is not empty:

  <ol>
    <li>Let <var>current ancestor</var> be the last member of <var>ancestor
    list</var>.

    <li>Remove the last member from <var>ancestor list</var>.

    <li>Let <var>target</var> be the [[child]] of <var>current ancestor</var>
    that is equal to either <var>node</var> or the last member of <var>ancestor
    list</var>.

    <li>If <var>target</var> is an <span>inline node</span> that is not a
    [[br]], and its [[nextsibling]] is a [[br]], remove <var>target</var>'s
    [[nextsibling]] from its [[parent]].

    <li>Let <var>preceding siblings</var> be the [[precedingsiblings]] of
    <var>target</var>, and let <var>following siblings</var> be the
    [[followingsiblings]] of <var>target</var>.

    <li><span>Indent</span> <var>preceding siblings</var>.

    <li><span>Indent</span> <var>following siblings</var>.
  </ol>

  <li><span>Outdent</span> <var>original ancestor</var>.
</ol>

<p>To <dfn>fix orphaned list items</dfn> in a list of [[nodes]] <var>node
list</var>:

<ol>
  <li>For each [[li]] <var>item</var> in <var>node list</var>:

  <ol>
      <li>If <var>item</var>'s [[parent]] is not an [[ol]], unset
      <var>item</var>'s <code data-anolis-spec=html
      title=attr-li-value>value</code> attribute, if set.
      <!-- IE9, Firefox 4.0, and Opera 11.10 keep the value attribute even if
      the parent is now a ul.  Chrome 12 dev strips it even if the parent is
      now an ol.  The spec makes more sense. -->

      <li>If <var>item</var> has no attributes and its [[parent]] is not an
      [[ol]] or [[ul]], remove <var>item</var>, <span>preserving its
      descendants</span>.

      <li>Otherwise, if <var>item</var>'s [[parent]] is not an [[ol]] or
      [[ul]], <span>set the tag name</span> of <var>item</var> to "div".
  </ol>
</ol>

<p>A <dfn>potential indentation element</dfn> is either a [[blockquote]], or a
[[div]] that has a [[style]] attribute that sets "margin" or some subproperty
of it.

<p class=XXX>Terminology is inconsistent with "modifiable" etc. used for inline
styles.

<p>An <dfn>indentation element</dfn> is an <span>potential indentation
element</span> that has no attributes other than one or more of

<ul>
  <li>a [[style]] attribute that sets no properties other than "margin",
  "border", "padding", or subproperties of those;

  <li>a <code data-anolis-spec=html title=classes>class</code> attribute;

  <li>a <code data-anolis-spec=html title="the dir attribute">dir</code>
  attribute.
</ul>

<dd><strong>State</strong>:

<dd><strong>Value</strong>:


<dt><code title><dfn title=command-removeformat>removeFormat</dfn></code>
<!--
Tested in IE 9, Firefox 4.0, Chrome 12 dev, Opera 11.00.

Tags stripped by everyone: b big cite code dfn em font i ins kbd samp s small
  strike strong sub sup tt u var
Tags left alone by everyone: br hr img

Unrecognized elements: stripped by Firefox and Opera, left alone by IE and
  Chrome.

blink: stripped only by IE
abbr: stripped only by Firefox
a, wbr: stripped only by Opera

nobr: left alone only by Firefox
acronym, bdo, q: left alone only by Opera

bdi, del, mark, span, svg: treated the same as unknown elements

All elements whose default rendering is display: block are left untouched by
all browsers (although IE seems to throw an exception on <marquee> for some
reason).

It's not clear to me why we should leave <a> alone, but everyone but Opera
does.  In OpenOffice.org 3.2.1, doing "Default Formatting (Ctrl+M)" doesn't
remove links.  In Microsoft Word 2007, doing "Clear Formatting" also doesn't
remove links.  Verdict: don't remove links.  Apparently they don't logically
qualify as "formatting".

Conclusion: leave alone a, br, hr, img, wbr.  Strip everything else, including
unrecognized elements, although of course not block elements.  Also we should
probably treat all replaced elements the same as <img>, although I didn't test
that (somehow I doubt it will come up much).  <video> behaves the same as
<img>, although Firefox adds tabindex=0 (???), so I'm assuming the rest are
similar.  Also, I'll keep all foreign elements and form elements.


Browsers will split up all these inline elements if the selection is contained
within them.  Opera does strip unrecognized elements with display: block if
they're within the selection, but doesn't split them up if they contain the
selection.

Upon consideration, I've decided to go for something for now that's totally
different from what any browser does: get rid of all elements actually
contained in the selection (pretty much matching browsers), but for elements
containing the selection, I'll just run all the other styling commands in a
fashion that will reset the style in normal cases.  This avoids having to
create a lot of new logic to decide exactly what we can split up or not, and
should be able to correctly remove anything that can actually be created by
these algorithms.

This approach currently results in incorrect behavior in some cases for
non-modifiable elements with default styling, like <code>.  The correct
approach is probably to declare these elements modifiable; this would roughly
match what browsers do.  I'm ignoring the issue for now, because such elements
cannot actually be created by implementations of execCommand(), so they're not
likely to be common.  Also, the way pushing down styles works right now is that
the element is destroyed and the style is recreated, which isn't going to work
for elements like <code> or <tt> or <mark> that we don't normally create.
-->

<dd><strong>Action</strong>:

<ol>
  <li><span>Decompose</span> the [[range]], and let <var>node list</var> be the
  result.

  <li>For each <var>node</var> in <var>node list</var>, unset the [[style]]
  attribute of <var>node</var> (if it's an [[element]]) and then all its
  [[element]] [[descendants]].

  <li>Let <var>elements to remove</var> be a list of all <span title="HTML
  element">HTML elements</span> that are the same as or [[descendants]] of some
  member of <var>node list</var> and have non-null [[parents]] and satisfy
  (insert conditions here).

  <p class=XXX>The conditions are not so simple to define, because we want to
  include non-conforming elements, which HTML doesn't give content models.  If
  everything had categories, we'd want something like "either it's
  unrecognized, or it's phrasing content that's not also embedded or
  interactive".  Except this has weird corner-cases like ins and del that are
  sometimes phrasing and sometimes flow.

  <li>For each <var>element</var> in <var>elements to remove</var>:

  <ol>
    <li>While <var>element</var> has [[children]], insert the first [[child]]
    of <var>element</var> into the [[parent]] of <var>element</var> immediately
    before <var>element</var>, <span>preserving ranges</span>.

    <li>Remove <var>element</var> from its [[parent]].
  </ol>

  <li>For each of the entries in the following table, in the given order:
  <span>decompose</span> the [[range]] again; then <span>set the value</span>
  of the resulting [[nodes]], with <var>command</var> and <var>new value</var>
  as given.

  <p class=XXX>This has no relationship to what browsers actually do, although
  it mostly works okay.  If I don't throw it out and replace it with something
  more like what browsers do, it still probably needs refinement to handle some
  elements that it doesn't deal with yet.

  <table>
    <tr><th><var>command</var> <th><var>new value</var>
    <tr><td>subscript <td>"baseline"
    <!-- superscript not needed, subscript does the same thing.  We run this
    first so <sub>/<sup> won't upset fontSize. -->
    <tr><td>bold <td>"normal"
    <tr><td>fontName <td>null
    <tr><td>fontSize <td>null
    <tr><td>foreColor <td>null
    <tr><td>hiliteColor <td>null
    <tr><td>italic <td>"normal"
    <tr><td>strikethrough <td>null
    <tr><td>underline <td>null
  </table>
</ol>

<dd><strong>State</strong>:

<dd><strong>Value</strong>:


<dt><code title><dfn title=command-strikethrough>strikethrough</dfn></code>

<dd><strong>Action</strong>: <span>Decompose</span> the [[range]].  If the
state of the [[range]] for this command is then true, <span>set the
value</span> of each returned [[node]] to null.  Otherwise, <span title="set
the value">set their value</span> to "line-through".

<p class=XXX>Has all the same problems as underline.

<dd><strong>State</strong>: True if every <span>editable</span> [[text]] node
that is <span>effectively contained</span> in the [[range]] has <span>effective
value</span> "line-through".  Otherwise false.

<dd><strong>Value</strong>: Always the empty string.


<dt><code title><dfn title=command-stylewithcss>styleWithCSS</dfn></code>
<!-- IE9 and Opera 11.00 don't support this command.  By and large, they act
the way Gecko and WebKit do when styleWithCSS is off.  Gecko invented it, and
WebKit also supports it:

https://bugs.webkit.org/show_bug.cgi?id=13490

The default in Firefox 4.0 is off, while all other browsers behave like the
default is on (and IE/Opera give no way to turn it off), so I default it to on.
-->

<dd><strong>Action</strong>: Convert <var>value</var> to a boolean according
to the algorithm in WebIDL, and set the <span>CSS styling flag</span> to the
result.

<p class=XXX>Properly cross-reference.

<dd><strong>State</strong>: True if the <span>CSS styling flag</span> is
true, otherwise false.

<dd><strong>Value</strong>:


<dt><code title><dfn title=command-subscript>subscript</dfn></code>

<dd><strong>Action</strong>: <span>Decompose</span> the [[range]].  If the
state of the [[range]] for this command is then true, <span>set the
value</span> of each returned [[node]] with <var>new value</var> "baseline".
Otherwise, <span title="set the value">set their value</span> with <var>new
value</var> "baseline", then <span>decompose</span> the [[range]] again and
<span>set the value</span> of each returned [[node]] with <var>new value</var>
"sub".

<dd><strong>State</strong>: True if every <span>editable</span> [[text]] node
that is <span>effectively contained</span> in the [[range]] has <span>effective
value</span> "sub".  Otherwise false.

<dd><strong>Value</strong>:

<dd><strong>Relevant CSS Property</strong>: "vertical-align"


<dt><code title><dfn title=command-superscript>superscript</dfn></code>

<dd><strong>Action</strong>: <span>Decompose</span> the [[range]].  If the
state of the [[range]] for this command is then true, <span>set the
value</span> of each returned [[node]] with <var>new value</var> "baseline".
Otherwise, <span title="set the value">set their value</span> with <var>new
value</var> "baseline", then <span>decompose</span> the [[range]] again and
<span>set the value</span> of each returned [[node]] with <var>new value</var>
"super".

<dd><strong>State</strong>: True if every <span>editable</span> [[text]] node
that is <span>effectively contained</span> in the [[range]] has <span>effective
value</span> "super".  Otherwise false.

<dd><strong>Value</strong>:

<dd><strong>Relevant CSS Property</strong>: "vertical-align"


<dt><code title><dfn title=command-underline>underline</dfn></code>

<dd><strong>Action</strong>: <span>Decompose</span> the [[range]].  If the
state of the [[range]] for this command is then true, <span>set the
value</span> of each returned [[node]] to null.  Otherwise, <span title="set
the value">set their value</span> to "underline".

<div class=XXX>
<p>There are a lot of problems with underline color and thickness, because
text-decoration in CSS is horrible:

<ul>
  <li>Pushing down underlines can change their color, since the color of an
  underline follows the color of the element where it's declared instead of the
  text it's drawn under.  This could be fixed by adding a special case for this
  condition and inserting extra color rules, such as by setting a color on the
  underlining element and then having another element inside it that resets the
  color.  Horrible, but that's text-decoration for you.  Alternatively, the new
  text-decoration-color property in the CSS 3 Text draft could come in handy
  here, in which case we'd degrade pretty gracefully in legacy UAs.

  <li>Underline thickness depends on font-size in all rendering engines but
  WebKit, so pushing them down creates thickness problems as well as color
  problems.  Working around this is a similar story to the previous, except we
  have no text-decoration-width property yet (see <a
  href="http://lists.w3.org/Archives/Public/www-style/2011Mar/0593.html">feedback
  to www-style</a>).

  <li>The preceding two points can't be avoided, because the only way to remove
  underlines in CSS is to push down styles (unlike most other things where you
  could override it).  Recent (February 2011) CSS 3 Text drafts have added
  support for a "text-decoration-line: cancel-underline" property, but we can
  only use that if there's no other possibility, since it won't work in legacy
  browsers.  (Although we should use it once there's no other possibility.)

  <li>More generally, from a user's perspective, color and thickness of
  underlines is going to be more or less random if they're applying them to
  text with varying size or color.  If they underline a bunch of text all at
  once, it will all get the same color/thickness, probably.  But if they
  underline letter-by-letter, it probably will vary.  But sometimes when they
  underline a bunch of text at once it will also vary, if the algorithm decides
  to create multiple elements for whatever reason (like an intervening
  unwrappable node).  This is unlikely to match user expectations.  There's
  not much we can do about this without entirely revamping text-decoration, so
  we'll have to live with it.

  <li>Currently we don't treat non-underline text-decorations properly, because
  we have no way to set (or cancel) underlines independently of other
  text-decorations from within CSS.  I've sent <a
  href="http://lists.w3.org/Archives/Public/www-style/2011Mar/0591.html">feedback
  to www-style</a>.
</ul>

<p>I'll revisit some of these issues when I get feedback on www-style, either
using the newly-specced features or working around their absence as the case
may be.
</div>

<dd><strong>State</strong>: True if every <span>editable</span> [[text]] node
that is <span>effectively contained</span> in the [[range]] has <span>effective
value</span> "underline".  Otherwise false.

<dd><strong>Value</strong>: Always the empty string.


<dt><code title><dfn title=command-unlink>unlink</dfn></code>

<dd><strong>Action</strong>:
<!--
IE 9 RC unlinks the whole link you're pointing at, while others only
unlink the current text.  The latter behavior seems less expected, as with
createLink, although I can't articulate precisely why.  Word 2007 and
OpenOffice.org 3.2.1 (Ubuntu) seem to give an option to remove the whole link
or none of it, which backs the spec's requirement.  See also #whatwg logs
starting at 2011-05-13 at 16:53 EDT (UTC-0400).
-->

<ol>
  <li>Let <var>hyperlinks</var> be a list of every [[a]] element that has an
  [[href]] attribute and is [[contained]] in the [[range]] or is an
  [[ancestor]] of one of its [[boundarypoints]].

  <li><span>Clear the value</span> of each member of <var>hyperlinks</var>.
</ol>

<dd><strong>State</strong>: Always false.

<dd><strong>Value</strong>: Always the empty string.


<dt><code title><dfn title=command-usecss>useCSS</dfn></code>
<!-- Supported by Firefox 4.0, but not IE9 or Opera 11.00 (which don't support
styleWithCSS either), nor by Chrome 12 dev (which does support styleWithCSS.
useCSS was the original feature in Mozilla 1.3, but the meaning is backward, so
Gecko added styleWithCSS as a replacement. -->

<dd><strong>Action</strong>: Convert <var>value</var> to a boolean according
to the algorithm in WebIDL, and set the <span>CSS styling flag</span> to the
negation of the result.  Since the effect of this command is the opposite of
what one would expect, user agents are encouraged to point authors to <code
title=command-stylewithcss>styleWithCSS</code> when <code
title=command-usecss>useCSS</code> is used, such as by logging a warning to an
error console.

<p class=XXX>Properly cross-reference.

<p class=XXX>The meaning of this command is backwards, and only Gecko supports
it.  It would be great if Gecko would agree to drop support, so that we could
get rid of it.

<dd><strong>State</strong>:

<dd><strong>Value</strong>:



<h2 class=no-num id=references>References</h2><!--REFS-->
<p>All references are normative unless marked "Non-normative".</p>
<div id=anolis-references></div>


<h2 class=no-num>Acknowledgements</h2>
<p>Thanks to:

<ul>
  <li>Google, for funding this work
  <li>Ian Hickson, for overseeing it
  <li>Julie Parent, Ojan Vafai, Alex Russel, and Eric Seidel for their <a
  href=http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2009-December/024627.html>research</a>
  on how browsers and other rich text editors behave in many common scenarios
  <li>Ehsan Akhgari, Tim Down, Ryosuke Niwa, Julie Parent, and Roland Steiner
  for their feedback on drafts of this document
</ul>

<script src=http://www.whatwg.org/specs/web-apps/current-work/dfn.js></script>
<!-- vim: set expandtab shiftwidth=2 tabstop=2: -->
