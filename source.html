<!doctype html>
<meta charset=utf-8>
<title>HTML Editing Commands</title>
<link rel=stylesheet href=http://www.whatwg.org/style/specification>
<style>
 pre, code { font-family:monospace, sans-serif; }
 h2 code, h3 code, h4 code,
 h2 :link, h3 :link, h4 :link,
 h2 :visited, h3 :visited, h4 :visited
 { font:inherit; color:inherit; font-style:italic; }
 @media print {
   :not([data-anolis-spec]) > [data-anolis-spec]::after {
     content: "[" attr(data-anolis-spec) "]";
     font-size: 0.6em;
     vertical-align: super;
     text-transform: uppercase;
   }
 }
</style>
<body class=draft>
<div class=head id=head>
<h1>HTML Editing Commands</h1>
<h2 class="no-num no-toc">Work in Progress &mdash; Last Update [DATE: 01 Jan 1901]</h2>
<dl>
 <dt>Editor
 <dd>Aryeh Gregor &lt;ayg+spec@aryeh.name>

 <dt>Version history
 <dd><a href=http://aryeh.name/gitweb.cgi?p=editcommands>http://aryeh.name/gitweb.cgi?p=editcommands</a>
</dl>
</div>


<h2 class=no-num>Table of contents</h2>
<!--toc-->


<h2>Introduction</h2>
<p>This specification defines commands to edit HTML documents programmatically.
The APIs specified here were originally introduced in Microsoft's Internet
Explorer, but have subsequently been copied by other browsers in a haphazard
and imprecise fashion.  Although the behavior specified here does not exactly
match any browser at the time of writing, it can serve as a target to converge
to in the future.

<p>Where the reasoning behind the specification is of interest, such as when
major preexisting rendering engines are known not to match it, the reasoning is
included in HTML comments so as not to distract the reader.


<h2>Issues</h2>

<ul>
  <li><p>Need to make CSS terminology more precise, about setting/unsetting CSS
  properties.  The intent is to modify the style attribute, CSSOM-style.

  <li><p>Also not sure about computed style.  There are differences between
  "computed" and "used" and things like that, what do we actually want here?

  <li><p>Some of the DOM stuff might benefit from more precision.  E.g., is
  there a precise algorithm for what it means to append a node someplace, if
  that node is already somewhere in the DOM?  What does that do if it's
  selected, it has state (like a video or animated image), etc.?
</ul>


<h2>Definitions</h2>

<p>A [[node]] is an <dfn>HTML element</dfn> if it is an [[element]] whose
[[namespace]] is the <span data-anolis-spec=domcore>HTML namespace</span>.

<p>The <dfn>first node</dfn> of a [[range]] is the [[node]] returned by the
following algorithm:

<ol>
  <li><p>Let <var title>range</var> be the [[range]] under discussion.

  <li><p>If <var title>range</var>'s [[rangestart]] [[bpoffset]] is equal to
  the [[nodelength]] of its [[rangestart]] [[bpnode]], return the first
  [[node]] that is after the [[rangestart]] [[bpnode]] and all its
  [[descendants]] (if any) in [[treeorder]].  If there is no such [[node]],
  return the last [[node]] in the document.

  <li><p>If <var title>range</var>'s [[rangestart]] [[bpnode]] is a [[text]],
  [[comment]], or [[processinginstruction]] node, return that.

  <li><p>If <var title>range</var>'s [[rangestart]] [[bpnode]] has children,
  return the child with [[index]] equal to the [[rangestart]] [[bpoffset]].

  <li><p>Return <var title>range</var>'s [[rangestart]] [[bpnode]].
</ol>

<p>The <dfn>beginning element</dfn> of a [[range]] is its <span>first
node</span> if that is an [[element]]; or the parent of its <span>first
node</span>, if <em>that</em> is an [[element]]; or else null.

<p class=XXX>(It will be null only in weird cases, like selecting a comment
whose parent is a document, or the child of a document fragment, or whatever.
I'm ignoring those cases for now.)


<h2>Decomposing a Range into Nodes</h2>
<p>When a user agent is to <dfn>decompose a [[range]]</dfn> <var
title>range</var>, it must run the following steps.

<p class=note>The algorithm returns a list of [[node]]s in the [[range]] that
are not contained in any other [[node]] in the [[range]].  It splits [[text]]
nodes if necessary, but isn't picky about [[comment]]s or
[[processinginstruction]]s.

<ol>
  <li><p>Let <var title>start node</var>, <var title>start offset</var>, <var
  title>end node</var>, and <var title>end offset</var> be the [[rangestart]]
  and [[rangeend]] [[bpnodes]] and [[bpoffsets]] of <var title>range</var>,
  respectively.

  <li><p>If <var title>start node</var> or <var title>end node</var> is not an
  [[element]], [[text]], [[processinginstruction]], or [[comment]] node, or is
  not an [[element]] and has no parent, abort these steps.

  <p class=XXX>Figure out something sensible here.

  <li><p>If <var title>start node</var> and <var title>end node</var> are both
  [[text]] nodes, and <var title>start node</var> is the same as <var title>end
  node</var>, and neither <var title>start offset</var> nor <var title>end
  offset</var> is equal to 0 or the [[nodelength]] of <var title>start
  node</var>:

  <ol>
    <li><p>Run <code data-anolis-spec=domcore
    title=dom-Text-splitText>splitText(<var title>start offset</var>)</code> on
    <var title>start node</var> and set <var title>start node</var> to the
    result.

    <li><p>Run <code data-anolis-spec=domcore
    title=dom-Text-splitText>splitText(<var title>end offset</var> &minus; <var
    title>start offset</var>)</code> on <var title>start node</var> and set
    <var title>start node</var> to the previous sibling of the result.

    <li><p>Return the list consisting of the single [[node]] <var title>start
    node</var>, and abort these steps.
  </ol>

  <li><p>If <var title>start node</var> is a [[text]] node and <var title>start
  offset</var> is neither 0 nor the [[nodelength]] of <var title>start
  node</var>, run <code data-anolis-spec=domcore
  title=dom-Text-splitText>splitText(<var title>start offset</var>)</code> on
  <var title>start node</var> and set <var title>start node</var> to the
  returned node.  Set <var title>start offset</var> to 0.

  <li><p>If <var title>end node</var> is a [[text]] node and <var title>end
  offset</var> is neither 0 nor the [[nodelength]] of <var title>end
  node</var>, run <code data-anolis-spec=domcore
  title=dom-Text-splitText>splitText(<var title>end offset</var>)</code> on
  <var title>end node</var> and set <var title>end node</var> to the previous
  sibling of the returned node.  Set <var title>end offset</var> to the
  [[nodelength]] of the new <var title>end node</var>.

  <li><p>If <var title>start node</var> is an [[element]] with at least one
  child, let <var title>node</var> be the child of <var title>start node</var>
  with [[index]] <var title>start offset</var>.

  <li><p>Otherwise, if <var title>start node</var> is a [[text]] node and <var
  title>start offset</var> is its [[nodelength]], let <var title>node</var> be
  the first [[node]] after <var title>start node</var> in [[treeorder]].

  <li><p>Otherwise, let <var title>node</var> be <var title>start node</var>.

  <li><p>If <var title>end node</var> is an [[element]] and <var title>end
  offset</var> is not 0, let <var title>end</var> be the child of <var
  title>end node</var> with [[index]] <var title>end offset</var> &minus; 1.

  <li><p>Otherwise, if <var title>end offset</var> is 0, let <var
  title>end</var> be the first [[node]] before <var title>end node</var> in
  [[treeorder]].

  <li><p>Otherwise, let <var title>end</var> be <var title>end node</var>.

  <!-- We try to include a node's parent instead of that node if possible,
  because this generally reduces the number of nodes we're handling.  So if the
  string "oo bar" was selected in <b>Foo <i>bar</i></b>, we'd add the <i> to
  the selection, even if the browser registered the end as the text node "bar".
  -->
  <li><p>While <var title>node</var> is the first child of its parent and <var
  title>end</var> is not a [[descendant]] of <var title>node</var>'s parent,
  set <var title>node</var> to its parent.

  <li><p>While <var title>end</var> is the last child of its parent and <var
  title>node</var> is not a [[descendant]] of <var title>end</var>'s parent,
  set <var title>end</var> to its parent.

  <li><p>Let <var title>node list</var> be an empty list of [[node]]s.

  <li><p>While <var title>node</var> is not after <var title>end</var> in
  [[treeorder]]:

  <ol>
    <li><p>Append <var title>node</var> to <var title>node list</var>.

    <li><p>Set <var title>node</var> to the first [[node]] in [[treeorder]]
    that is after <var title>node</var> and (if applicable) all its
    [[descendants]].  If no such [[node]] exists, break out of these substeps.

    <li><p>While <var title>node</var> is an [[ancestor]] of <var
    title>end</var>, set <var title>node</var> to its first child.
  </ol>

  <li><p>Return <var title>node list</var>.
</ol>


<h2>Unstyling an element</h2>
<p>When a user agent is to <dfn>unstyle an element</dfn>, it must run the
following steps.  This algorithm might remove the element from the DOM and
insert other elements in its place, in which case it will return an ordered
list of the element's former children.

<ol>
  <li><p>Let <var title>element</var> be the <code
  data-anolis-spec=domcore>Element</code> to be unstyled.

  <li><p>Let <var title>property name</var> and <var title>tag list</var> be as
  in the invoking algorithm.

  <li><p>Let <var title>element children</var> be the [[element]] children of
  <var title>element</var>.

  <li><p><span title="unstyle an element">Unstyle</span> each [[element]] in
  <var title>element children</var>, in order.

  <p class=note>Unstyling an element can change the number of children its
  parent has, so the list of children to unstyle needs to be computed
  beforehand.

  <li><p>Let <var title>children</var> be an empty list of [[node]]s.

  <li><p>If either

  <ul>
    <li><p><var title>element</var> is an <span>HTML element</span> with
    [[localname]] either "span" or in <var title>tag list</var>, and it has
    only a single attribute, and that attribute is named "style", and
    that style attribute sets only the CSS property <var title>property
    name</var>; or

    <li><p><var title>element</var> is an <span>HTML element</span> with
    [[localname]] in <var title>tag list</var> and it has no attributes,
  </ul>

  <p>then:

  <ol>
    <li><p>While <var title>element</var> has children:

    <ol>
      <li><p>Let <var title>child</var> be the first child of <var
      title>element</var>.

      <li><p>Append <var title>child</var> to <var title>children</var>.

      <li><p>Insert <var title>child</var> as the previous sibling of <var
      title>element</var>.
    </ol>

    <li><p>Remove <var title>element</var>.

    <li><p>Return <var title>children</var> and abort this algorithm.
  </ol>

  <li><p>Unset the CSS property <var title>property name</var> of <var
  title>element</var>.

  <li><p>If <var title>element</var> is an <span>HTML element</span> with
  [[localname]] in <var title>tag list</var>:

  <ol>
    <li><p>Let <var title>new element</var> be a new <span>HTML element</span> with
    [[localname]] "span", with the same attributes and <code
    data-anolis-spec=domcore title=dom-Node-ownerDocument>ownerDocument</code>
    as <var title>element</var>.

    <li><p>Append <var title>new element</var> to <var title>element</var>'s
    parent as the previous sibling of <var title>element</var>.

    <li><p>While <var title>element</var> has children:

    <ol>
      <li><p>Let <var title>child</var> be the first child of <var
      title>element</var>.

      <li><p>Append <var title>child</var> to <var title>children</var>.

      <li><p>Append <var title>child</var> as the last child of <var title>new
      element</var>.
    </ol>

    <li><p>Remove <var title>element</var>.
  </ol>

  <li><p>Return <var title>children</var>.
</ol>


<h2>Styling a Range</h2>
<p>When a user agent is to <dfn>style a <code
data-anolis-spec=domrange>Range</code></dfn> <var title>range</var>, it must
run the following steps.  There are three inputs: a CSS property name <var
title>property name</var>, a new value <var title>property value</var>, and a
nonempty list of strings <var title>tag list</var>.

<div class=XXX>
<p>This description tries to keep the algorithm as simple as possible at the
expense of producing much more complicated markup in some cases than a slightly
more sophisticated algorithm.  It's similar to what Gecko does in spirit,
although the details differ.  The basic cause of most of the ugly markup is
that we don't bake in any element nesting restrictions, so <code
title>&lt;em>Abc&lt;/em> &lt;em>def&lt;/em></code> becomes <code title>&lt;em
style=font-weight:bold>Abc&lt;/em>&lt;b> &lt;/b>&lt;em
style=font-weight:bold>def&lt;/em></code> instead of just <code
title>&lt;b>&lt;em>Abc&lt;/em> &lt;em>def&lt;/em>&lt;/b></code>.  Otherwise
we'd have to add content model checks.  Maybe this is worth it?  IE and WebKit
seem to do it, Gecko and Opera seem not to (they only wrap text nodes AFAICT).

<p>I did add some complication by saying conflicting inline style needs to be
removed.  This is what WebKit does.  Gecko and IE9 leave it alone, which leads
to stuff like <code title>&lt;b>&lt;span
style=font-weight:100>Foo&lt;/span>&lt;/b></code> that doesn't actually work.
Opera avoids the problem by producing code like <code title>&lt;span
style=font-weight:100>&lt;b>Foo&lt;/b>&lt;/span></code>, but that doesn't work
with the CSS-based strategy.
</div>

<ol>
  <li><p>Let <var title>node list</var> be the result of <span title="decompose
  a range">decomposing</span> <var title>range</var>.

  <li><p>For each <var title>node</var> in <var title>node list</var>, in <span
  data-anolis-spec=domcore>tree order</span>:

  <ol>
    <li><p>If <var title>node</var> is an <code
    data-anolis-spec=domcore>Element</code>:

    <ol>
      <li><p>If <var title>node</var> is an <span>HTML element</span> with [[localname]]
      in <var title>tag list</var>, unset the CSS property <var title>property
      name</var> of <var title>node</var>.  Otherwise, set the CSS property
      <var title>property name</var> of <var title>node</var> to <var
      title>property value</var>.

      <li><p>Let <var title>element children</var> be the [[element]] children
      of <var title>node</var>.

      <li><p><span title="unstyle an element">Unstyle</span> each [[element]]
      in <var title>element children</var>, in order.

      <p class=note>Unstyling an element can change the number of children its
      parent has, so the list of children to unstyle needs to be computed
      beforehand.
    </ol>

    <li><p>Otherwise, if <var title>node</var> is a <code
    data-anolis-spec=domcore>Text</code> node:

    <ol>
      <!-- This next step is not strictly necessary from a user point of view,
      since there's no visible difference.  We could just always insert a new
      element.  But that can drastically complicate the DOM if there are lots
      of text nodes, which happens easily when the algorithms here are invoked
      a lot: you get splitText() called when decomposing ranges, and unstyling
      elements can also dump their text node children into the DOM next to
      other text nodes. -->
      <li><p>If the previous sibling of <var title>node</var> is an <span>HTML
      element</span> with [[localname]] in <var title>tag list</var> with no
      attributes, let <var title>new parent</var> equal the previous sibling of
      <var title>node</var>.

      <li><p>Otherwise, let <var title>new parent</var> be a new <span>HTML
      element</span> with [[localname]] equal to the first string in <var
      title>tag list</var>, with no attributes, and <code
      data-anolis-spec=domcore
      title=dom-Node-ownerDocument>ownerDocument</code> the same as <var
      title>node</var>.  Append <var title>new parent</var> to <var
      title>node</var>'s parent as the previous sibling of <var
      title>node</var>.

      <li><p>Append <var title>node</var> to <var title>new parent</var> as
      its last child.
    </ol>

    <li><p>Otherwise, do nothing.
  </ol>
</ol>

<!-- Out of IE9, Gecko, WebKit, and Opera, when asked to (e.g.) bold an
element, IE9 and WebKit and Opera wrap various descendants in <b> or <strong>;
Gecko just adds a style attribute.  The latter is simpler, particularly because
you then don't have to worry about making sure you only insert your tags in a
valid place (which you have to so that text/html serialization is possible, if
nothing else).  I originally specced the former approach, available in git
history. -->


<h2>Unstyling a Range</h2>
<p>When a user agent is to <dfn>unstyle a <code
data-anolis-spec=domrange>Range</code></dfn> <var title>range</var>, it must
run the following steps.  There are three inputs: a CSS property name <var
title>property name</var>, a new value <var title>property value</var>, and a
possibly empty list of strings <var title>tag list</var>.

<ol>
  <li><p>Let <var title>node list</var> be the result of <span title="decompose
  a range">decomposing</span> <var title>range</var>.

  <li><p>For each <var title>node</var> in <var title>node list</var>, in
  order:

  <ol>
    <li><p>If <var title>node</var> is an <code
    data-anolis-spec=domcore>Element</code>:

    <ol>
      <li><p>Let <var title>children</var> be the result of <span
      title="unstyle an element">unstyling</span> <var title>node</var>.

      <li><p>If <var title>node</var> no longer has a parent:

      <ol>
        <li><p>Insert all the [[node]]s in <var title>children</var> into <var
        title>node list</var> immediately after <var title>node</var>, in
        order.

        <li><p>Continue with the next [[node]] in <var title>node list</var>,
        if any.

        <p class=note>The next [[node]] will be the first former child of <var
        title>node</var>, if <var title>node</var> had children.
      </ol>

      <li><p>If the computed value of <var title>property name</var> for <var
      title>node</var> is not <var title>property value</var>, set the CSS
      property <var title>property name</var> of <var title>node</var> to <var
      title>property value</var>.

      <li><p>Let <var title>element children</var> be the [[element]] children
      of <var title>node</var>.

      <li><p><span title="unstyle an element">Unstyle</span> each [[element]]
      in <var title>element children</var>, in order.

      <p class=note>Unstyling an element can change the number of children its
      parent has, so the list of children to unstyle needs to be computed
      beforehand.
    </ol>

    <li><p>Otherwise, if <var title>node</var> is a <code
    data-anolis-spec=domcore>Text</code> node and the computed value of <var
    title>property name</var> for <var title>node</var>'s parent is not <var
    title>property value</var>:

    <ol>
      <li><p>Let <var title>new parent</var> be a new <span>HTML element</span> with
      [[localname]] "span", with no attributes, and with <code
      data-anolis-spec=domcore
      title=dom-Node-ownerDocument>ownerDocument</code> equal to <var
      title>node</var>'s.

      <li><p>Set the CSS property <var title>property name</var> of <var
      title>new parent</var> to <var title>property value</var>.

      <li><p>Insert <var title>new parent</var> as <var title>node</var>'s
      previous sibling.

      <li><p>Append <var title>node</var> to <var title>new parent</var> as its
      child.
    </ol>

    <li><p>Otherwise, do nothing.
  </ol>
</ol>


<h2>Commands</h2>
<p>The <dfn title=execCommand()><code>execCommand(<var title>commandId</var>,
<var title>showUI</var>, <var title>value</var>)</code></dfn> method on the
<code data-anolis-spec=html>HTMLDocument</code> interface allows scripts to
perform actions on the current selection or at the current caret position.
Generally, these commands would be used to implement editor UI, for example
having a "delete" button on a toolbar.

<p>There are three variants to this method, with one, two, and three arguments
respectively. The <var title>showUI</var> and <var title>value</var>
parameters, even if specified, are ignored except where otherwise stated.

<p>When <code>execCommand()</code> is invoked, the user agent must run the
following steps:

<ol>
  <li>Let <var title>selection</var> be the result of calling <code
  data-anolis-spec=domrange
  title=dom-Document-getSelection>getSelection()</code> on the <span
  data-anolis-spec=domrange>context object</span>.

  <li>For each <code data-anolis-spec=domrange>Range</code> associated with
  <var title>selection</var>, in order, take the action from the list below
  given by <var title>commandId</var>.
</ol>

<dl>
<dt><code title><dfn title=command-bold>bold</dfn></code>
<dd><p>If the <span>beginning element</span> of the [[range]] has font-weight
with computed value not equal to "bold" (or less than 700), the user agent must
<span title="style a range">style the [[range]]</span> with <var title>property
name</var> "font-weight", <var title>property value</var> "bold", and <var
title>tag list</var> ["b", "strong"].  Otherwise, it must <span title="unstyle
a range">unstyle it</span> with <var title>property name</var> "font-weight",
<var title>property value</var> "normal", and <var title>tag list</var> ["b",
"strong"].

<p class=XXX>b has font-weight: bolder, not font-weight: bold.  This produces
unexpected behavior if there are font-weight: lighters or something thrown
around.  Maybe that's not worth worrying about.

<dt><code title><dfn title=command-italic>italic</dfn></code>
<dd><p>If the <span>beginning element</span> of the [[range]] has font-style
with computed value not equal to "italic" or "oblique", the user agent must
<span title="style a range">style the [[range]]</span> with <var title>property
name</var> "font-style", <var title>property value</var> "italic", and <var
title>tag list</var> ["i", "em"].  Otherwise, it must <span title="unstyle
a range">unstyle it</span> with <var title>property name</var> "font-style",
<var title>property value</var> "normal", and <var title>tag list</var> ["i",
"em"].

<dt><code title><dfn title=command-underline>underline</dfn></code>
<dd><p>If the <span>beginning element</span> of the [[range]] has
text-decoration with a computed value that does not include "underline", the
user agent must <span title="style a range">style the [[range]]</span> with
<var title>property name</var> "text-decoration", <var title>property
value</var> "underline", and <var title>tag list</var> ["u"].  Otherwise, it
must <span title="unstyle a range">unstyle it</span> with <var title>property
name</var> "text-decoration", <var title>property value</var> "none", and <var
title>tag list</var> ["u"].

<p class=XXX>This is wrong, it will clear strikethrough and overline.  Also,
computed style isn't useful, because text-decoration doesn't inherit.
</dl>


<h2 class=no-num id=references>References</h2><!--REFS-->
<p>All references are normative unless marked "Non-normative".</p>
<div id=anolis-references></div>


<!--
<h2 class=no-num>Acknowledgements</h2>
<p>...
-->
<script src=http://www.whatwg.org/specs/web-apps/current-work/dfn.js></script>
