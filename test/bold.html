<!doctype html>
<title>execCommand("bold") tests</title>
<button onclick=bold()>Bold</button>
<div contenteditable=true id=test>
	<br> <br>
	Some simple text<br>
	<span>Some more text</span><br>
	<b>Some more text</b><br>
	<strong>Some more text</strong><br>
	<span style=font-weight:bold>Some more text</span><br>
	<span style=font-weight:bolder>Some more text</span><br>
	<span style=font-weight:lighter>Some more text</span><br>
	<span style=font-weight:900>Some more text</span><br>
	<span style=font-weight:100>Some more text</span><br>
	<i>Some more text</i><br>
	<span style=font-style:italic>Some more text</span><br>
	<span style=font-style:italic;font-weight:bold>Some more text</span><br>
	<em style=font-weight:bold>Some more text</em><br>
	<b>Some <span style=font-weight:light>more <b>te<span style=font-weight:bold>xt<strong>!</strong></span></b></span></b><br>
	<p>Some simple text
	<p><span>Some more text</span>
	<p><b>Some more text</b>
	<p><strong>Some more text</strong>
	<p><span style=font-weight:bold>Some more text</span>
	<p><span style=font-weight:bolder>Some more text</span>
	<p><span style=font-weight:lighter>Some more text</span>
	<p><span style=font-weight:900>Some more text</span>
	<p><span style=font-weight:100>Some more text</span>
	<p><i>Some more text</i>
	<p><span style=font-style:italic>Some more text</span>
	<p><span style=font-style:italic;font-weight:bold>Some more text</span>
	<p><em style=font-weight:bold>Some more text</em>
	<p><b>Some <span style=font-weight:light>more <b>te<span style=font-weight:bold>xt<strong>!</strong></span></b></span></b>
</div>
<script>
"use strict";

var htmlNamespace = "http://www.w3.org/1999/xhtml";

function indexOf(node) {
	var ret = 0;
	while (node != node.parentNode.childNodes[ret]) {
		ret++;
	}
	return ret;
}

function nextNode(node) {
	if (node.hasChildNodes()) {
		return node.firstChild;
	}
	return nextNodeDescendants(node);
}

function previousNode(node) {
	if (node.previousSibling) {
		node = node.previousSibling;
		while (node.hasChildNodes()) {
			node = node.lastChild;
		}
		return node;
	}
	if (node.parentElement) {
		return node.parentElement;
	}
	return null;
}

function nextNodeDescendants(node) {
	while (node && !node.nextSibling) {
		node = node.parentElement;
	}
	if (!node) {
		return null;
	}
	return node.nextSibling;
}

function convertProperty(propertyName) {
	// Hack for now
	return "font-weight";
}


function firstNode(range) {
	if (range.startContainer.nodeType == Node.TEXT_NODE
	|| range.startContainer.nodeType == Node.COMMENT_NODE
	|| range.startContainer.nodeType == Node.PROCESSING_INSTRUCTION_NODE) {
		return range.startContainer;
	}

	if (range.startContainer.childNodes.length > range.startOffset) {
		return range.startContainer.childNodes[range.startOffset];
	}

	return range.startContainer;
}

function beginningElement(range) {
	var first = firstNode(range);
	if (first.nodeType == Node.ELEMENT_NODE) {
		return first;
	}

	if (first.parentNode.nodeType == Node.ELEMENT_NODE) {
		return first.parentNode;
	}

	return null;
}

function decomposeRange(range) {
	// "Let start node, start offset, end node, and end offset be the start and
	// end nodes and offsets of range, respectively."
	var startNode = range.startContainer;
	var startOffset = range.startOffset;
	var endNode = range.endContainer;
	var endOffset = range.endOffset;

	// "If start node or end node is not an Element, Text,
	// ProcessingInstruction, or Comment node, or is not an Element and has no
	// parent, abort these steps."
	// Skip the sanity check about node types/detached non-elements

	// "If start node is a Text node and start offset is neither 0 nor the
	// length of start node, run splitText(start offset) on start node and set
	// start node to the returned node. Set start offset to 0."
	if (startNode.nodeType == Node.TEXT_NODE
	&& startOffset != 0
	&& startOffset != startNode.data.length) {
		startNode = startNode.splitText(startOffset);
		startOffset = 0;
	}

	// "If end node is a Text node and end offset is neither 0 nor the length
	// of end node, run splitText(end offset) on end node and set end node to
	// the previous sibling of the returned node. Set end offset to the length
	// of the new end node."
	if (endNode.nodeType == Node.TEXT_NODE
	&& endOffset != 0
	&& endOffset != endNode.data.length) {
		endNode = endNode.splitText(endOffset).previousSibling;
		endOffset = endNode.data.length;
	}

	var node;
	// "If start node is an Element with at least one child, let node be the
	// child of start node with index start offset."
	if (startNode.nodeType == Node.ELEMENT_NODE
	&& startNode.hasChildNodes()) {
		node = startNode.childNodes[startOffset];
	// "Otherwise, if start node is a Text node and start offset is its length,
	// let node be the first Node after start node in tree order."
	} else if (startNode.nodeType == Node.TEXT_NODE
	&& startOffset == startNode.data.length) {
		node = nextNode(startNode);
	// "Otherwise, let node be start node."
	} else {
		node = startNode;
	}

	var end;
	// "If end node is an Element and end offset is not 0, let end be the child
	// of end node with index end offset âˆ’ 1."
	if (endNode.nodeType == Node.ELEMENT_NODE && endOffset != 0) {
		end = endNode.childNodes[endOffset - 1];
	// "Otherwise, if end offset is 0, let end be the first Node before end
	// node in tree order."
	} else if (endOffset == 0) {
		end = previousNode(endNode);
	// "Otherwise, let end be end node."
	} else {
		end = endNode;
	}

	// "Let node list be an empty list of Nodes."
	var nodeList = [];

	// "While node is not after end in tree order:"
	while (node && !(end.compareDocumentPosition(node) & 4)) {
		// "Append node to node list."
		nodeList.push(node);
		// "Set node to the first Node in tree order that is after node and (if
		// applicable) all its descendants. If no such Node exists, break out
		// of these substeps."
		//
		// If no such node exists, node will be set to null by this line and
		// we'll break out due to the "node" part of the while condition.
		node = nextNodeDescendants(node);
	}

	return nodeList;
}

function unstyleElement(element, propertyName, tagList) {
	// "If either
	//
	// * element is an HTML element with name either "span" or in tag list, and
	//   it has only a single attribute, and that attribute is named "style",
	//   and that style attribute sets only the CSS property property name; or
	//
	// * element is an HTML element with name in tag list and it has no
	//   attributes,
	//
	// then:"
	if (
		(element.namespaceURI == htmlNamespace
		&& (element.nodeName == "SPAN" || tagList.indexOf(element.nodeName.toLowerCase()) != -1)
		&& element.attributes.length == 1
		&& element.attributes[0].localName == "style"
		&& element.style.length == 1
		&& element.style.item(0) == convertProperty(propertyName)
		)
		||
		(element.namespaceURI == htmlNamespace
		&& tagList.indexOf(element.nodeName.toLowerCase()) != -1
		&& element.attributes.length == 0)
	) {
		// "While element has children, insert the first child of element as
		// the previous sibling of element."
		while (element.hasChildNodes()) {
			element.parentNode.insertBefore(element.childNodes[0], element);
		}
		// "Remove element."
		element.parentNode.removeChild(element);
		// "Abort this algorithm."
		return;
	}

	// "Unset the CSS property property name of element."
	element.style[propertyName] = '';
	if (element.getAttribute("style") == "") {
		element.removeAttribute("style");
	}

	// "If element is an HTML element with name in tag list:"
	if (element.namespaceURI == htmlNamespace
	&& tagList.indexOf(element.tagName.toLowerCase()) != -1) {
		// "Let new element be a new HTML element with name "span", with the
		// same attributes and ownerDocument as element."
		var newElement = element.ownerDocument.createElement("span");
		for (var j = 0; j < element.attributes.length; j++) {
			// FIXME: Namespaces?
			newElement.setAttribute(element.attributes[j].localName, element.attributes[j].value);
		}

		// "Append new element to element's parent as the previous sibling of
		// element."
		element.parentNode.insertBefore(newElement, element);

		// "While element has children, append the first child of element as
		// the last child of new element."
		while (element.hasChildNodes()) {
			newElement.appendChild(element.childNodes[0]);
		}
		// "Remove element."
		element.parentNode.removeChild(element);
	}
}

function unstyleElementDescendants(element, propertyName, tagList) {
	for (var i = 0; i < element.childNodes.length; i++) {
		if (element.childNodes[i].nodeType != Node.ELEMENT_NODE) {
			continue;
		}
		unstyleElement(element.childNodes[i], propertyName, tagList);
		unstyleElementDescendants(element.childNodes[i], propertyName, tagList);
	}
}

function styleRange(range, propertyName, propertyValue, tagList) {
	// "Let node list be the result of decomposing range."
	var nodeList = decomposeRange(range);

	// "For each node in node list, in tree order:"
	for (var i = 0; i < nodeList.length; i++) {
		var node = nodeList[i];
		// "If node is an Element:"
		if (node.nodeType == Node.ELEMENT_NODE) {
			// "If node is an HTML element with name in tag list, unset the CSS
			// property property name of node. Otherwise, set the CSS property
			// property name of node to property value."
			if (node.namespaceURI == htmlNamespace
			&& tagList.indexOf(node.tagName.toLowerCase()) != -1) {
				node.style[propertyName] = '';
				if (node.getAttribute("style") == "") {
					node.removeAttribute("style");
				}
			} else {
				node.style[propertyName] = propertyValue;
			}

			// "Unstyle each Element descendant of node."
			unstyleElementDescendants(node, propertyName, tagList);
		// "Otherwise, if node is a Text node:"
		} else if (node.nodeType == Node.TEXT_NODE) {
			// "Let new parent be a new HTML element with name equal to the first
			// string in tag list, with no attributes, and ownerDocument the same
			// as node."
			var newParent = node.ownerDocument.createElement(tagList[0]);

			// "Append new parent to node's parent as the previous sibling of
			// node."
			node.parentNode.insertBefore(newParent, node);

			// "Append node to new parent as its last child."
			newParent.appendChild(node);
		}
		// "Otherwise, do nothing."
	}
}

function unstyleRange(range, propertyName, propertyValue, tagList) {
	// "Let node list be the result of decomposing range."
	var nodeList = decomposeRange(range);

	// "For each node in node list, in order:"
	for (var i = 0; i < nodeList.length; i++) {
		// "If node is an Element:"
		if (node.nodeType == Node.ELEMENT_NODE) {
			// "Unstyle node."
			unstyleElement(node, propertyName, tagList);

			// "If the computed value of property name for node is not property
			// value, set the CSS property property name of node to property
			// value."
			if (getComputedStyle(node)[propertyName] != propertyValue) {
				node.style[propertyName] = propertyValue;
			}

			// "Unstyle each Element descendant of node."
			unstyleElementDescendants(node, propertyName, tagList);
		// "Otherwise, if node is a Text node and the computed value of
		// property name for node's parent is not property value:"
		} else if (node.nodeType == Node.TEXT_NODE
		&& getComputedStyle(node.parentNode)[propertyName] != propertyValue) {
			// "Let new parent be a new HTML element with name "span", with no
			// attributes, and with ownerDocument equal to node's."
			var newParent = node.ownerDocument.createElement("span");

			// "Set the CSS property property name of new parent to property
			// value."
			newParent.style[propertyName] = propertyValue;

			// "Insert new parent as node's previous sibling."
			node.parentNode.insertBefore(newParent, node);

			// "Append node to new parent as its child."
			newParent.appendChild(node);
		}
		// "Otherwise, do nothing."
	}
}

function bold() {
	var selection = getSelection();
	for (var i = 0; i < selection.rangeCount; i++) {
		if (getComputedStyle(beginningElement(selection.getRangeAt(i))).fontWeight != "bold") {
			styleRange(selection.getRangeAt(i), "fontWeight", "bold", ["b", "strong"]);
		} else {
			styleRange(selection.getRangeAt(i), "fontWeight", "normal", ["b", "strong"]);
		}
	}
}
</script>
