<!doctype html>
<title>execCommand() experimental implementation</title>
<p><label>Command: <input></label>
   <label>Value: <input></label>
<script>
var command = document.querySelector("input");
var val = document.querySelectorAll("input")[1];
</script>
<p>Spec:
<button tabindex=-1 accesskey=a onclick='myExecCommand(command.value, null, val.value)'>exec</button>
<button tabindex=-1 accesskey=s onclick='var ret = myQueryCommandState(command.value); alert(typeof ret + " \"" + ret + "\"")'>state</button>
<button tabindex=-1 accesskey=d onclick='var ret = myQueryCommandValue(command.value); alert(typeof ret + " \"" + ret + "\"")'>value</button>
<p>Actual:
<button tabindex=-1 accesskey=z onclick='execCommand(command.value, null, val.value)'>exec</button>
<button tabindex=-1 accesskey=x onclick='var ret = queryCommandState(command.value); alert(typeof ret + " \"" + ret + "\"")'>state</button>
<button tabindex=-1 accesskey=c onclick='var ret = queryCommandValue(command.value); alert(typeof ret + " \"" + ret + "\"")'>value</button>
<div contenteditable=true>
	Abcdef
</div>
<script>
"use strict";

var htmlNamespace = "http://www.w3.org/1999/xhtml";

function indexOf(node) {
	var ret = 0;
	while (node != node.parentNode.childNodes[ret]) {
		ret++;
	}
	return ret;
}

function nodeLength(node) {
	if (node.nodeType == Node.TEXT_NODE
	|| node.nodeType == Node.COMMENT_NODE
	|| node.nodeType == Node.PROCESSING_INSTRUCTION_NODE) {
		return node.data.length;
	}

	return node.childNodes.length;
}

function nextNode(node) {
	if (node.hasChildNodes()) {
		return node.firstChild;
	}
	return nextNodeDescendants(node);
}

function previousNode(node) {
	if (node.previousSibling) {
		node = node.previousSibling;
		while (node.hasChildNodes()) {
			node = node.lastChild;
		}
		return node;
	}
	if (node.parentNode
	&& node.parentNode.nodeType == Node.ELEMENT_NODE) {
		return node.parentNode;
	}
	return null;
}

function nextNodeDescendants(node) {
	while (node && !node.nextSibling) {
		node = node.parentNode;
	}
	if (!node) {
		return null;
	}
	return node.nextSibling;
}

function convertProperty(propertyName) {
	// Special-case for now
	var map = {
		"fontStyle": "font-style",
		"fontWeight": "font-weight",
		"textDecoration": "text-decoration",
	};
	if (typeof map[propertyName] != "undefined") {
		return map[propertyName];
	}

	return propertyName;
}


function firstNode(range) {
	// "If range's start offset is equal to the length of its start node,
	// return the first Node that is after the start node and all its
	// descendants (if any) in tree order. If there is no such Node, return the
	// last Node in the document."
	if (range.startOffset == nodeLength(range.startContainer)) {
		var ret = nextNodeDescendants(range.startContainer);
		if (!ret) {
			ret = range.startContainer;
			while (ret.hasChildNodes()) {
				ret = ret.childNodes[ret.childNodes.length - 1];
			}
		}
		return ret;
	}

	// "If range's start node is a Text, Comment, or ProcessingInstruction
	// node, return that."
	if (range.startContainer.nodeType == Node.TEXT_NODE
	|| range.startContainer.nodeType == Node.COMMENT_NODE
	|| range.startContainer.nodeType == Node.PROCESSING_INSTRUCTION_NODE) {
		return range.startContainer;
	}

	// "If range's start node has children, return the child with index equal
	// to the start offset."
	if (range.startContainer.hasChildNodes()) {
		return range.startContainer.childNodes[range.startOffset];
	}

	// "Return range's start node."
	return range.startContainer;
}

function beginningElement(range) {
	var first = firstNode(range);
	if (first.nodeType == Node.ELEMENT_NODE) {
		return first;
	}

	if (first.parentNode.nodeType == Node.ELEMENT_NODE) {
		return first.parentNode;
	}

	return null;
}

function activeRange(doc) {
	// "Let selection be the result of calling getSelection() on the Document."
	//
	// We call getSelection() on defaultView instead, because Firefox and Opera
	// don't follow the DOM Range spec here:
	// https://bugzilla.mozilla.org/show_bug.cgi?id=636512
	var selection = doc.defaultView.getSelection();

	// "If there are no Ranges associated with selection, return null."
	if (selection.rangeCount == 0) {
		return null;
	}

	// "Let start be the boundary point with the earliest position among all of
	// selection's Ranges' starts."
	var startNode = null;
	var startOffset = null;
	for (var i = 0; i < selection.rangeCount; i++) {
		if (startNode === null) {
			startNode = selection.getRangeAt(i).startContainer;
			startOffset = selection.getRangeAt(i).startOffset;
			continue;
		}
		var testRange = doc.createRange();
		testRange.setStart(startNode, startOffset);
		if (testRange.compareBoundaryPoints(Range.START_TO_START, selection.getRangeAt(i)) < 0) {
			startNode = selection.getRangeAt(i).startContainer;
			startOffset = selection.getRangeAt(i).startOffset;
		}
	}

	// "Return the last Range in selection whose start is start."
	for (var i = selection.rangeCount - 1; i >= 0; i--) {
		if (selection.getRangeAt(i).startContainer == startNode
		&& selection.getRangeAt(i).startOffset == startOffset) {
			return selection.getRangeAt(i);
		}
	}
}

function decomposeRange(range) {
	// "Let start node, start offset, end node, and end offset be the start and
	// end nodes and offsets of range, respectively."
	var startNode = range.startContainer;
	var startOffset = range.startOffset;
	var endNode = range.endContainer;
	var endOffset = range.endOffset;

	// "If start node or end node is not an Element, Text,
	// ProcessingInstruction, or Comment node, or is not an Element and has no
	// parent, abort these steps."
	// Skip the sanity check about node types/detached non-elements

	// "If start node and end node are both Text nodes, and start node is the
	// same as end node, and neither start offset nor end offset is equal to 0
	// or the length of start node:"
	if (startNode.nodeType == Node.TEXT_NODE
	&& endNode.nodeType == Node.TEXT_NODE
	&& startNode.isSameNode(endNode)
	&& startOffset != 0
	&& startOffset != startNode.data.length
	&& endOffset != 0
	&& endOffset != startNode.data.length) {
		// "Run splitText(start offset) on start node and set start node to the
		// result."
		startNode = startNode.splitText(startOffset);

		// "Run splitText(end offset − start offset) on start node and set
		// start node to the previous sibling of the result."
		startNode = startNode.splitText(endOffset - startOffset).previousSibling;

		// "Return the list consisting of the single Node start node, and abort
		// these steps."
		return [startNode];
	}

	// "If start node is a Text node and start offset is neither 0 nor the
	// length of start node, run splitText(start offset) on start node and set
	// start node to the returned node. Set start offset to 0."
	if (startNode.nodeType == Node.TEXT_NODE
	&& startOffset != 0
	&& startOffset != startNode.data.length) {
		startNode = startNode.splitText(startOffset);
		startOffset = 0;
	}

	// "If end node is a Text node and end offset is neither 0 nor the length
	// of end node, run splitText(end offset) on end node and set end node to
	// the previous sibling of the returned node. Set end offset to the length
	// of the new end node."
	if (endNode.nodeType == Node.TEXT_NODE
	&& endOffset != 0
	&& endOffset != endNode.data.length) {
		endNode = endNode.splitText(endOffset).previousSibling;
		endOffset = endNode.data.length;
	}

	var node;
	// "If start node is an Element with at least one child, let node be the
	// child of start node with index start offset."
	if (startNode.nodeType == Node.ELEMENT_NODE
	&& startNode.hasChildNodes()) {
		node = startNode.childNodes[startOffset];
	// "Otherwise, if start node is a Text node and start offset is its length,
	// let node be the first Node after start node in tree order."
	} else if (startNode.nodeType == Node.TEXT_NODE
	&& startOffset == startNode.data.length) {
		node = nextNode(startNode);
	// "Otherwise, let node be start node."
	} else {
		node = startNode;
	}

	var end;
	// "If end node is an Element and end offset is not 0, let end be the child
	// of end node with index end offset − 1."
	if (endNode.nodeType == Node.ELEMENT_NODE && endOffset != 0) {
		end = endNode.childNodes[endOffset - 1];
	// "Otherwise, if end offset is 0, let end be the first Node before end
	// node in tree order."
	} else if (endOffset == 0) {
		end = previousNode(endNode);
	// "Otherwise, let end be end node."
	} else {
		end = endNode;
	}

	// "While node is the first child of its parent and end is not a descendant
	// of node's parent, set node to its parent."
	while (node == node.parentNode.firstChild
	&& !(end.compareDocumentPosition(node.parentNode) & Node.DOCUMENT_POSITION_CONTAINS)) {
		node = node.parentNode;
	}

	// "While end is the last child of its parent and node is not a descendant
	// of end's parent, set end to its parent."
	while (end == end.parentNode.lastChild
	&& !(node.compareDocumentPosition(end.parentNode) & Node.DOCUMENT_POSITION_CONTAINS)) {
		end = end.parentNode;
	}

	// "Let node list be an empty list of Nodes."
	var nodeList = [];

	// "While node is not after end in tree order:"
	while (!(end.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_FOLLOWING)) {
		// "Append node to node list."
		nodeList.push(node);

		// "Set node to the first Node in tree order that is after node and (if
		// applicable) all its descendants. If no such Node exists, break out
		// of these substeps."
		node = nextNodeDescendants(node);
		if (!node) {
			break;
		}

		// "While node is an ancestor of end, set node to its first child."
		while (end.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINS) {
			node = node.firstChild;
		}
	}

	return nodeList;
}

function unstyleElement(element, propertyName, tagList) {
	// "Let element children be the Element children of element."
	var elementChildren = [];
	for (var j = 0; j < element.childNodes.length; j++) {
		if (element.childNodes[j].nodeType == Node.ELEMENT_NODE) {
			elementChildren.push(element.childNodes[j]);
		}
	}

	// "Unstyle each Element in element children, in order."
	for (var j = 0; j < elementChildren.length; j++) {
		unstyleElement(elementChildren[j], propertyName, tagList);
	}

	// "If either
	//
	// * element is an HTML element with name either "span" or in tag list, and
	//   it has only a single attribute, and that attribute is named "style",
	//   and that style attribute sets only the CSS property property name; or
	//
	// * element is an HTML element with name in tag list and it has no
	//   attributes,
	//
	// then:"
	if (
		(element.namespaceURI == htmlNamespace
		&& (element.nodeName == "SPAN" || tagList.indexOf(element.nodeName.toLowerCase()) != -1)
		&& element.attributes.length == 1
		&& element.attributes[0].localName == "style"
		&& element.style.length == 1
		&& element.style.item(0) == convertProperty(propertyName)
		)
		||
		(element.namespaceURI == htmlNamespace
		&& tagList.indexOf(element.nodeName.toLowerCase()) != -1
		&& element.attributes.length == 0)
	) {
		// "Let children be an empty list of Nodes."
		var children = [];

		// "While element has children:"
		while (element.hasChildNodes()) {
			// "Let child be the first child of element."
			var child = element.firstChild;

			// "Append child to children."
			children.push(child);

			// "Insert child as the previous sibling of element."
			element.parentNode.insertBefore(child, element);
		}

		// "Remove element."
		element.parentNode.removeChild(element);

		// "Return children."
		return children;
	}

	// "Unset the CSS property property name of element."
	element.style[propertyName] = '';
	if (element.getAttribute("style") == "") {
		element.removeAttribute("style");
	}

	// "If element is not an HTML element or its local name is not in tag list,
	// return the empty list."
	if (element.namespaceURI != htmlNamespace
	|| tagList.indexOf(element.tagName.toLowerCase()) == -1) {
		return [];
	}

	// "Let new element be a new HTML element with name "span", with the
	// same attributes and ownerDocument as element."
	var newElement = element.ownerDocument.createElement("span");
	for (var j = 0; j < element.attributes.length; j++) {
		// FIXME: Namespaces?
		newElement.setAttribute(element.attributes[j].localName, element.attributes[j].value);
	}

	// "Append new element to element's parent as the previous sibling of
	// element."
	element.parentNode.insertBefore(newElement, element);

	// "While element has children, append its first child as the last
	// child of new element."
	while (element.hasChildNodes()) {
		newElement.appendChild(element.firstChild);
	}

	// "Remove element."
	element.parentNode.removeChild(element);

	// "Return the one-Node list consisting of new element."
	return [newElement];
}

function styleRange(range, propertyName, propertyValue, tagList) {
	// Extra step to implement CSS value equality checking; this needs to be
	// specced somehow.
	var testEl = document.createElement("span");
	testEl.style[propertyName] = propertyValue;
	var expectedPropertyValue = testEl.style[propertyName];

	// "Let node list be the result of decomposing range."
	var nodeList = decomposeRange(range);

	// "For each node in node list, in tree order:"
	for (var i = 0; i < nodeList.length; i++) {
		var node = nodeList[i];
		// "If node is an Element:"
		if (node.nodeType == Node.ELEMENT_NODE) {
			// "Unset the CSS property property name of node."
			node.style[propertyName] = '';
			if (node.getAttribute("style") == "") {
				node.removeAttribute("style");
			}

			// "If the computed value of property name for node is not property
			// value, set the CSS property property name of node to property
			// value."
			if (getComputedStyle(node)[propertyName] != expectedPropertyValue) {
				node.style[propertyName] = propertyValue;
			}

			// "Let element children be the Element children of node."
			var elementChildren = [];
			for (var j = 0; j < node.childNodes.length; j++) {
				if (node.childNodes[j].nodeType == Node.ELEMENT_NODE) {
					elementChildren.push(node.childNodes[j]);
				}
			}

			// "Unstyle each Element in element children, in order."
			for (var j = 0; j < elementChildren.length; j++) {
				unstyleElement(elementChildren[j], propertyName, tagList);
			}
		// "Otherwise, if node is a Text node:"
		} else if (node.nodeType == Node.TEXT_NODE) {
			// "Let new parent be a new HTML element with local name equal to
			// the first string in tag list (or equal to "span" if tag list is
			// empty), with no attributes, and ownerDocument the same as node."
			var newParent = node.ownerDocument.createElement(tagList.length ? tagList[0] : "span");

			// "Append new parent to node's parent as the previous sibling of
			// node."
			node.parentNode.insertBefore(newParent, node);

			// "If the computed value of property name on new parent is not
			// equal to property value, set the CSS property property name of
			// new parent to property value."
			if (getComputedStyle(newParent)[propertyName] != expectedPropertyValue) {
				newParent.style[propertyName] = propertyValue;
			}

			// "Append node to new parent as its last child."
			newParent.appendChild(node);
		}
		// "Otherwise, do nothing."
	}
}

function unstyleRange(range, propertyName, propertyValue, tagList) {
	// Extra step to implement CSS value equality checking; this needs to be
	// specced somehow.
	var testEl = document.createElement("span");
	testEl.style[propertyName] = propertyValue;
	var expectedPropertyValue = testEl.style[propertyName];

	// "Let node list be the result of decomposing range."
	var nodeList = decomposeRange(range);

	// "For each node in node list, in order:"
	for (var i = 0; i < nodeList.length; i++) {
		var node = nodeList[i];

		// "If node is an Element:"
		if (node.nodeType == Node.ELEMENT_NODE) {
			// "Let extra nodes be the result of unstyling node."
			var extraNodes = unstyleElement(node, propertyName, tagList);

			// "If node no longer has a parent:"
			if (!node.parentNode) {
				// "Insert all the Nodes in extra nodes into node list
				// immediately after node, in order."
				//
				// splice() would be perfect, but it requires varargs.  :(
				nodeList = nodeList.slice(0, i + 1)
					.concat(extraNodes)
					.concat(nodeList.slice(i + 1));

				// "Continue with the next Node in node list, if any."
				continue;
			}

			// "If the computed value of property name for node is not property
			// value, set the CSS property property name of node to property
			// value."
			if (getComputedStyle(node)[propertyName] != expectedPropertyValue) {
				node.style[propertyName] = propertyValue;
			}

			// "Let element children be the Element children of node."
			var elementChildren = [];
			for (var j = 0; j < node.childNodes.length; j++) {
				if (node.childNodes[j].nodeType == Node.ELEMENT_NODE) {
					elementChildren.push(node.childNodes[j]);
				}
			}

			// "Unstyle each Element in element children, in order."
			for (var j = 0; j < elementChildren.length; j++) {
				unstyleElement(elementChildren[j], propertyName, tagList);
			}
		// "Otherwise, if node is a Text node and the computed value of
		// property name for node's parent is not property value:"
		} else if (node.nodeType == Node.TEXT_NODE
		&& getComputedStyle(node.parentNode)[propertyName] != expectedPropertyValue) {
			// "Let new parent be a new HTML element with name "span", with no
			// attributes, and with ownerDocument equal to node's."
			var newParent = node.ownerDocument.createElement("span");

			// "Set the CSS property property name of new parent to property
			// value."
			newParent.style[propertyName] = propertyValue;

			// "Insert new parent as node's previous sibling."
			node.parentNode.insertBefore(newParent, node);

			// "Append node to new parent as its child."
			newParent.appendChild(node);
		}
		// "Otherwise, do nothing."
	}
}

function myExecCommand(commandId, showUI, value) {
	commandId = commandId.toLowerCase();
	var range = activeRange(document);

	if (!range) {
		return;
	}

	switch (commandId) {
		case "bold":
		if (getState("bold", range)) {
			unstyleRange(range, "fontWeight", "normal", ["b", "strong"]);
		} else {
			styleRange(range, "fontWeight", "bold", ["b", "strong"]);
		}
		break;

		case "createlink":
		// "If value is the empty string, do nothing."
		if (value === "") {
			break;
		}

		// "Let node list be the result of decomposing the Range."
		var nodeList = decomposeRange(range);

		// "For each node in node list, in order:"
		for (var i = 0; i < nodeList.length; i++) {
			var node = nodeList[i];

			// "Let text nodes be a list of all Text node descendants of node,
			// or node itself if it's a Text node."
			var textNodes = [];
			if (node.nodeType == Node.TEXT_NODE) {
				textNodes.push(node);
			} else {
				for (var cur = node.firstChild;
				cur && cur.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINS;
				cur = nextNode(cur)) {
					if (cur.nodeType == Node.TEXT_NODE) {
						textNodes.push(cur);
					}
				}
			}

			// "For each text node in text nodes, in tree order:"
			for (var j = 0; j < textNodes.length; j++) {
				var textNode = textNodes[j];

				// "Let ancestor link be the parent of text node."
				var ancestorLink = textNode.parentNode;

				// "While ancestor link is not an HTML element, or its local
				// name is not "a", or it has no HTML attribute with local name
				// "href":"
				while (ancestorLink.namespaceURI != htmlNamespace
				|| ancestorLink.nodeType != Node.ELEMENT_NODE
				|| ancestorLink.tagName != "A"
				|| !ancestorLink.hasAttribute("href")) {
					// "If the parent of ancestor link is not an Element, set
					// ancestor link to null and break from this loop."
					if (!ancestorLink.parentNode
					|| ancestorLink.parentNode.nodeType != Node.ELEMENT_NODE) {
						ancestorLink = null;
						break;
					}

					// "Otherwise, set ancestor link to its parent."
					ancestorLink = ancestorLink.parentNode;
				}

				// "If ancestor link is not null, set its "href" attribute to
				// value and continue with the next text node."
				if (ancestorLink) {
					ancestorLink.setAttribute("href", value);
					continue;
				}

				// "Let new parent be a new HTML element with local name "a",
				// the same ownerDocument as text node, and a single HTML
				// attribute with local name "href" and value value."
				var newParent = textNode.ownerDocument.createElement("a");
				newParent.setAttribute("href", value);

				// "Insert new parent into text node's parent as the previous
				// sibling of text node."
				textNode.parentNode.insertBefore(newParent, textNode);

				// "Append text node to new parent as its last child."
				newParent.appendChild(textNode);
			}
		}

		case "foreColor":
		// Hacky test to see if the color is valid
		var testEl = document.createElement("span");
		testEl.style.color = value;
		if (testEl.style.color === "") {
			return;
		}
		styleRange(range, "color", value, []);
		break;

		case "italic":
		if (getState("italic", range)) {
			unstyleRange(range, "fontStyle", "normal", ["i", "em"]);
		} else {
			styleRange(range, "fontStyle", "italic", ["i", "em"]);
		}
		break;

		default:
		break;
	}
}

function myQueryCommandState(commandId) {
	commandId = commandId.toLowerCase();
	var range = activeRange(document);

	if (!range) {
		return false;
	}

	return getState(commandId, range);
}

function getState(commandId, range) {
	var style = getComputedStyle(beginningElement(range));

	switch (commandId) {
		case "bold":
		return style.fontWeight == "bold"
			|| (/^[0-9]+$/.test(style.fontWeight) && style.fontWeight >= 700);

		case "italic":
		return style.fontStyle == "italic" || style.fontStyle == "oblique";

		default:
		return false;
	}
}

function myQueryCommandValue(commandId) {
	commandId = commandId.toLowerCase();
	var range = activeRange(document);

	if (!range) {
		return "";
	}

	var style = getComputedStyle(beginningElement(range));

	switch (commandId) {
		case "backcolor":
		// "Let element be the beginning element of the Range."
		var element = beginningElement(range);
		// "While the computed style of "background-color" on element is any
		// fully transparent value, set element to its parent."
		while (element.nodeType == Node.ELEMENT_NODE
		&& (getComputedStyle(element).backgroundColor == "rgba(0, 0, 0, 0)"
		|| getComputedStyle(element).backgroundColor === ""
		|| getComputedStyle(element).backgroundColor == "transparent")) {
			element = element.parentNode;
		}
		// "Return the computed style of "background-color" for element."
		if (element.nodeType != Node.ELEMENT_NODE) {
			return 'rgb(255, 255, 255)';
		}
		return getComputedStyle(element).backgroundColor;

		case "fontname":
		return style.fontFamily;

		case "forecolor":
		return style.color;

		default:
		return "";
	}
}
</script>
