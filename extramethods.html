<!doctype html>
<meta charset=utf-8>
<title>Auto-running queryCommand*() tests</title>
<!-- @{ -->
<link rel=stylesheet href=tests.css>
<style>
body > div > table > tbody > tr { display: table-row !important }
.yes, .no, .maybe { font-size: 2.5em }
body > div > table > tbody > tr > td,
body > div > table > tbody > tr > th {
	width: 15%;
}
body > div > table > tbody > tr > td[rowspan],
body > div > table > tbody > tr > th:first-child {
	width: 50%;
}
body > div > table > tbody > tr > td:last-child,
body > div > table > tbody > tr > th:last-child {
	width: 5%;
}
td.alert {
	font-weight: bold;
	color: red;
}
</style>
<p>Legend: {[ are the selection anchor, }] are the selection focus, {}
represent an element boundary point, [] represent a text node boundary point.
Syntax and some of the tests taken from <a
href=http://www.browserscope.org/richtext2/test>Browserscope</a>.  data-start
and data-end attributes also represent element boundary points, with the node
being the element with the attribute and the offset given as the attribute
value, for cases where HTML parsing doesn't allow text nodes.  Currently we
don't really pay attention to reversed selections at all, so they might get
displayed as forwards or such.

<h1>Table of Contents</h1>
<ul>
</ul>
<script src=implementation.js></script>
<script src=tests.js></script>
<!-- @} -->
<script>
"use strict";
// Let's have a more useful toolbar
//@{
document.querySelector("#toolbar").innerHTML = '<label><input id=enabled-checkbox type=checkbox checked onclick="updateDisplayedRows()"> Display enabled</label>'
	+ '<label><input id=indeterm-checkbox type=checkbox checked onclick="updateDisplayedRows()"> Display indeterminate</label>'
	+ '<label><input id=state-checkbox type=checkbox checked onclick="updateDisplayedRows()"> Display state</label>'
	+ '<label><input id=value-checkbox type=checkbox checked onclick="updateDisplayedRows()"> Display value</label>'
	+ '<style id=row-hider></style>';

// Number of rows to display per entry
var rowCount;

document.querySelector("#enabled-checkbox").checked = localStorage["extramethods-display-enabled"] != "false";
document.querySelector("#indeterm-checkbox").checked = localStorage["extramethods-display-indeterm"] != "false";
document.querySelector("#state-checkbox").checked = localStorage["extramethods-display-state"] != "false";
document.querySelector("#value-checkbox").checked = localStorage["extramethods-display-value"] != "false";

function updateDisplayedRows() {
	var enabled = document.querySelector("#enabled-checkbox").checked;
	var indeterm = document.querySelector("#indeterm-checkbox").checked;
	var state = document.querySelector("#state-checkbox").checked;
	var value = document.querySelector("#value-checkbox").checked;

	localStorage["extramethods-display-enabled"] = enabled;
	localStorage["extramethods-display-indeterm"] = indeterm;
	localStorage["extramethods-display-state"] = state;
	localStorage["extramethods-display-value"] = value;

	var numberChecked = Number(enabled) + Number(indeterm) + Number(state) + Number(value);
	var boxes = document.querySelectorAll("#toolbar input");
	var hiddenRows = [];
	for (var i = 0; i < boxes.length; i++) {
		// Don't let the user uncheck the last box
		boxes[i].disabled = numberChecked == 1 && boxes[i].checked;
		if (!boxes[i].checked) {
			hiddenRows.push(i);
		}
	}

	// We always need to include the first row in rowCount when using it to set
	// rowspan, because the first cell of the first row contains the test and
	// has to always display.
	rowCount = 1 + Number(indeterm) + Number(state) + Number(value);

	var hideCss = "";
	if (hiddenRows.length) {
		for (var i = 0; i < hiddenRows.length; i++) {
			if (hiddenRows[i] == 0) {
				hideCss += "body > div > table > tbody > tr:nth-child(4n + 2) > :not(:first-child), ";
			} else {
				hideCss += "body > div > table > tbody > tr:nth-child(4n + " + ((hiddenRows[i] + 2) % 4) + "):not(:first-child), ";
			}
		}
		hideCss = hideCss.replace(/, $/, "");
		hideCss += " { display: none !important }";
	}
	document.querySelector("#row-hider").textContent = hideCss;

	var cells = document.querySelectorAll("[rowspan]");
	for (var i = 0; i < cells.length; i++) {
		cells[i].rowSpan = rowCount;
	}
}
updateDisplayedRows();
//@}

// Set up all the HTML automatically so I can add new commands to test without
// copy-pasting in five places
//@{
(function() {
	var toc = document.querySelector("ul");
	for (var command in tests) {
		var li = document.createElement("li");
		li.innerHTML = "<a href=#" + command + ">" + command + "</a>";
		toc.appendChild(li);

		var div = document.createElement("div");
		div.id = command;
		div.innerHTML = "<h1>" + command + "</h1>"
			+ "<button onclick=\"runTests('" + command + "')\">Run tests</button>"
			+ (command in notes ? "<p>" + notes[command] : "")
			+ "<table border=1><tr><th>Input <th>Feature <th>Spec <th>Browser <th>Same?</table>"
			+ "<p><label>New test input: <input></label>"
			+ "<button onclick=\"addTest('" + command + "')\">Add test</button>";
		document.body.appendChild(div);
	}
})();
//@}

// Get rid of values and condense tests that differ only in value
//@{
(function() {
	for (var command in tests) {
		tests[command] = tests[command].map(function(test) {
			return typeof test == "string"
				? test
				: test[1];
		}).filter(function(el, i, arr) {
			return arr.slice(0, i).indexOf(el) == -1;
		});
	}
})();
//@}

function runTests(command) {
//@{
    var runTestsButton = document.querySelector("#" + command + " button");
    if (runTestsButton.textContent != "Run tests") {
        return;
    }
    runTestsButton.parentNode.removeChild(runTestsButton);

	var addTestButton = document.querySelector("#" + command + " button");
	var input = document.getElementById(command).getElementsByTagName("input")[0];
	for (var i = 0; i < tests[command].length; i++) {
		// This code actually focuses and clicks everything because for some
		// reason, anything else doesn't work in IE9 . . .
		//
		// In case the input contains something unpleasant like newlines, we
		// smuggle in the string as a data attribute, not just the value.  This
		// is probably unnecessarily magic.
		input.value = tests[command][i];
		input.setAttribute("data-input", tests[command][i]);
		input.focus();
		addTestButton.click();
	}
	input.value = "";

	document.querySelector("#" + command).scrollIntoView();
}
//@}

function addTest(command) {
//@{
	var tr = doSetup("#" + command + " > table", 0);

	var test;
	var input = document.getElementById(command).getElementsByTagName("input")[0];

	if (input.hasAttribute("data-input")) {
		test = input.getAttribute("data-input");
	} else {
		test = input.value;
	}
	input.removeAttribute("data-input");

	var inputCell = document.createElement("td");
	tr.appendChild(inputCell);
	try {
		var points = setupCell(inputCell, test);
	} catch (e) {
		tr.style.display = "table-row !important";
		inputCell.colSpan = 5;
		inputCell.className = "alert";
		inputCell.textContent = "Exception: " + e;
		inputCell.style.display = "table-cell !important";
		tr.parentNode.appendChild(document.createElement("tr"));
		tr.parentNode.appendChild(document.createElement("tr"));
		tr.parentNode.appendChild(document.createElement("tr"));
		return;
	}
	inputCell.rowSpan = rowCount;
	inputCell.firstChild.contentEditable = "true";
	inputCell.firstChild.spellcheck = false;

	compareMethods(tr, command, points, "Enabled", myQueryCommandEnabled, document.queryCommandEnabled);

	var newTr = document.createElement("tr");
	tr.parentNode.appendChild(newTr);
	compareMethods(newTr, command, points, "Indeterm", myQueryCommandIndeterm, document.queryCommandIndeterm);

	newTr = document.createElement("tr");
	tr.parentNode.appendChild(newTr);
	compareMethods(newTr, command, points, "State", myQueryCommandState, document.queryCommandState);

	newTr = document.createElement("tr");
	tr.parentNode.appendChild(newTr);
	compareMethods(newTr, command, points, "Value", myQueryCommandValue, document.queryCommandValue);

	inputCell.firstChild.contentEditable = "inherit";
	inputCell.firstChild.removeAttribute("spellcheck");
	inputCell.firstChild.innerHTML = test;
	inputCell.lastChild.textContent = inputCell.firstChild.innerHTML;

	tr.className = (" " + tr.className + " ").replace(" active ", "").trim();
}
//@}

function compareMethods(tr, command, points, label, specFn, browserFn) {
//@{
	var labelCell = document.createElement("th");
	labelCell.textContent = label;
	tr.appendChild(labelCell);

	var specCell = document.createElement("td");
	tr.appendChild(specCell);

	var specResult;
	try {
		var range = document.createRange();
		range.setStart(points[0], points[1]);
		range.setEnd(points[2], points[3]);
		if (range.collapsed) {
			range.setEnd(points[0], points[1]);
		}

		specResult = specFn(command, range);
	} catch (e) {
		specCell.textContent = "Exception: " + e;
		if (typeof e == "object" && "stack" in e) {
			specCell.textContent += " (stack: " + e.stack + ")";
		}
	}

	if (typeof specResult != "undefined") {
		specCell.textContent = typeof specResult + ' "' + specResult + '"';
	}


	var browserCell = document.createElement("td");
	tr.appendChild(browserCell);

	if (typeof browserFn == "undefined") {
		browserCell.textContent = "Method undefined";
	} else {
		var browserResult;
		try {
			setSelection(points[0], points[1], points[2], points[3]);
			browserResult = browserFn.call(document, command);
		} catch (e) {
			browserCell.textContent = "Exception: " + e;
			if (typeof e == "object" && "stack" in e) {
				browserCell.textContent += " (stack: " + e.stack + ")";
			}
		}

		getSelection().removeAllRanges();

		if (typeof browserResult != "undefined") {
			browserCell.textContent = typeof browserResult + ' "' + browserResult + '"';
		}
	}


	var sameCell = document.createElement("td");
	tr.appendChild(sameCell);
	if (specResult === browserResult) {
		sameCell.className = "yes";
		sameCell.textContent = "\u2713";
	} else {
		sameCell.className = "no";
		sameCell.textContent = "\u2717";
	}
}
//@}
</script>
<!-- vim: foldmarker=@{,@} foldmethod=marker
-->
